{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Portafolio Rodrigo Zarate Fernandez","text":""},{"location":"#descripcion","title":"Descripcion:","text":"<p>Estudiante de Ingenier\u00eda Mecatr\u00f3nica en la Universidad Iberoamericana Puebla.</p> <p>Apasionado por la automatizaci\u00f3n, la rob\u00f3tica, la inteligencia artificial y la fabricaci\u00f3n digital.</p> <p>Aqu\u00ed comparto mis proyectos, prototipos y experiencias que reflejan mi crecimiento como ingeniero y mi visi\u00f3n de la tecnolog\u00eda como herramienta de cambio.</p>"},{"location":"ADC_lux/","title":"Medici\u00f3n de Iluminancia (Lux\u00f3metro) con ADC en Raspberry Pi Pico","text":"<p>Este proyecto implementa un lux\u00f3metro digital utilizando el convertidor anal\u00f3gico\u2013digital (ADC) del microcontrolador Raspberry Pi Pico. El sistema realiza una lectura continua de luz ambiental, aplica una media m\u00f3vil sobre 16 muestras y calcula un porcentaje de luminosidad aproximado.</p>"},{"location":"ADC_lux/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Lux\u00f3metro con ADC y media m\u00f3vil </li> <li>Autor: Rodrigo Z\u00e1rate </li> <li>Asignatura: Sistemas Embebidos </li> <li>Fecha: 11/11/2025 </li> <li>Descripci\u00f3n breve: Sistema que mide el nivel de iluminaci\u00f3n mediante un sensor anal\u00f3gico conectado al pin ADC0 (GPIO26), filtrando el ruido con un promedio m\u00f3vil y mostrando el porcentaje de luz en consola.</li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>, <code>hardware/adc.h</code>) T\u00e9cnicas clave: Lectura ADC, media m\u00f3vil, procesamiento de se\u00f1ales anal\u00f3gicas. Plataforma: Raspberry Pi Pico / Pico 2  </p>"},{"location":"ADC_lux/#material-utilizado","title":"Material utilizado","text":"<ul> <li>1 \u00d7 Raspberry Pi Pico o Pico 2  </li> <li>1 \u00d7 Sensor de luz (LDR o fototransistor)  </li> <li>1 \u00d7 Resistencia fija (10 k\u03a9) para divisor de tensi\u00f3n  </li> <li>Cables jumper y protoboard  </li> </ul>"},{"location":"ADC_lux/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar el ADC del Pico para leer niveles de voltaje del sensor LDR.  </li> <li>Implementar un filtro de media m\u00f3vil con 16 muestras.  </li> <li>Calcular un porcentaje de luminosidad relativa basado en las lecturas promedio.  </li> <li>Mostrar en consola los valores instant\u00e1neos, la suma de muestras y el resultado filtrado.  </li> </ul>"},{"location":"ADC_lux/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"Componente GPIO Descripci\u00f3n LDR (sensor de luz) 26 (ADC0) Entrada anal\u00f3gica Resistencia fija (10 k\u03a9) \u2014 Conectada en divisor de tensi\u00f3n GND \u2014 Tierra com\u00fan <p>Notas de conexi\u00f3n: - El LDR se conecta en un divisor de voltaje con una resistencia de 10 k\u03a9. - La uni\u00f3n central del divisor se conecta a GPIO26 (ADC0). - Conectar GND com\u00fan y alimentaci\u00f3n de 3.3 V al sensor.  </p> <p>Esquema simplificado:</p>"},{"location":"ADC_lux/#4-codigo-principal","title":"4) C\u00f3digo principal","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n\n#define ADC_INPUT 0       // Canal ADC0\n#define N_muestras 16     // N\u00famero de muestras para el promedio\n\nint main() {\n    stdio_init_all();\n    adc_init();\n    adc_gpio_init(26);     // GPIO26 = ADC0\n    adc_select_input(ADC_INPUT);\n\n    uint16_t buffer[N_muestras];\n    int sum = 0;\n    uint8_t indice = 0;\n    uint8_t cuenta = 0;\n\n    while (true) {\n        uint16_t adc = adc_read(); // Lectura ADC (0\u20134095)\n\n        if (cuenta &lt; N_muestras) {\n            buffer[indice] = adc;\n            sum += adc;\n            cuenta++;\n            indice++;\n        } else {\n            sum -= buffer[indice];       // Restar valor m\u00e1s antiguo\n            buffer[indice] = adc;        // Agregar nuevo valor\n            sum += adc;                  // Sumar nuevo valor\n            indice++;\n            if (indice &gt;= N_muestras) indice = 0;\n\n            printf(\"Muestra:%u\\n\", adc);\n            printf(\"Suma:%u\\n\", sum);\n            printf(\"N_muestras:%u\\n\", N_muestras);\n\n            int promedio = sum / N_muestras;\n            int porcentaje = ((-promedio * 100.0f) / 2300.0f) + 100;\n            porcentaje = porcentaje % 100;\n\n            printf(\"Promedio:%u\\n\", promedio);\n            printf(\"Porcentaje:%u%%\\n\", porcentaje);\n            sleep_ms(200);\n        }\n    }\n}\n</code></pre>"},{"location":"ADC_lux/#5-explicacion-del-codigo","title":"5) Explicaci\u00f3n del c\u00f3digo","text":""},{"location":"ADC_lux/#a-lectura-del-adc","title":"a) Lectura del ADC","text":"<ul> <li>Se inicializa el ADC interno de 12 bits de resoluci\u00f3n (0\u20134095).  </li> <li><code>adc_gpio_init(26)</code> configura el pin GPIO26 como entrada anal\u00f3gica.  </li> <li><code>adc_select_input(0)</code> selecciona el canal ADC0 correspondiente.</li> </ul>"},{"location":"ADC_lux/#b-promedio-movil","title":"b) Promedio m\u00f3vil","text":"<ul> <li>Se almacenan 16 muestras en un buffer circular.  </li> <li>Cada nueva lectura reemplaza la m\u00e1s antigua, actualizando la suma total.  </li> <li>Se obtiene el promedio dividiendo la suma entre <code>N_muestras</code>.</li> </ul>"},{"location":"ADC_lux/#c-calculo-del-porcentaje","title":"c) C\u00e1lculo del porcentaje","text":"<ul> <li>El promedio se transforma en un valor porcentual relativo a un rango m\u00e1ximo (~2300).  </li> <li>Este valor puede calibrarse seg\u00fan las condiciones de luz ambiental o el tipo de sensor.</li> </ul>"},{"location":"ADC_lux/#d-salida-en-consola","title":"d) Salida en consola","text":"<ul> <li>Se imprimen valores en consola: muestra individual, suma acumulada, promedio y porcentaje de luz.  </li> <li><code>sleep_ms(200)</code> reduce la frecuencia de muestreo a ~5 Hz para mejor lectura humana.</li> </ul>"},{"location":"ADC_lux/#6-resultados-esperados","title":"6) Resultados esperados","text":"<ul> <li>En entornos oscuros, el valor ADC aumenta \u2192 porcentaje bajo.  </li> <li>En luz intensa, el ADC disminuye \u2192 porcentaje alto.  </li> <li>Los valores se actualizan de forma continua y estable, filtrados con la media m\u00f3vil.  </li> </ul> <p>Ejemplo de salida en terminal: <pre><code>Muestra: 1800\nSuma: 28800\nN_muestras: 16\nPromedio: 1800\nPorcentaje: 21%\n</code></pre> Resultado esperado: medici\u00f3n estable de iluminaci\u00f3n ambiental con respuesta proporcional a la cantidad de luz recibida por el sensor.</p>"},{"location":"ADC_servo/","title":"Control de Servomotor con Potenci\u00f3metro (Raspberry Pi Pico)","text":"<p>Este proyecto implementa el control anal\u00f3gico de un servomotor mediante un potenci\u00f3metro, utilizando el ADC y PWM del microcontrolador Raspberry Pi Pico. Se emplea un filtro de media m\u00f3vil para suavizar la se\u00f1al del potenci\u00f3metro y evitar movimientos bruscos del servo.</p>"},{"location":"ADC_servo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Control de Servomotor por Potenci\u00f3metro </li> <li>Autor: Rodrigo Z\u00e1rate </li> <li>Asignatura: Sistemas Embebidos </li> <li>Fecha: 11/11/2025 </li> <li>Descripci\u00f3n breve: Sistema de control anal\u00f3gico que ajusta el \u00e1ngulo de un servomotor proporcionalmente a la lectura de un potenci\u00f3metro. El valor le\u00eddo se filtra mediante un promedio m\u00f3vil antes de generar la se\u00f1al PWM de control.</li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C++ con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>, <code>hardware/adc.h</code>, <code>hardware/pwm.h</code>) T\u00e9cnicas clave: Lectura ADC, PWM, control proporcional, filtrado con media m\u00f3vil. Plataforma: Raspberry Pi Pico / Pico 2  </p>"},{"location":"ADC_servo/#material-utilizado","title":"Material utilizado","text":"<ul> <li>1 \u00d7 Raspberry Pi Pico o Pico 2  </li> <li>1 \u00d7 Servomotor (SG90 o similar)  </li> <li>1 \u00d7 Potenci\u00f3metro de 10 k\u03a9  </li> <li>Cables jumper y protoboard  </li> </ul>"},{"location":"ADC_servo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar el ADC para leer el valor del potenci\u00f3metro.  </li> <li>Implementar un promedio m\u00f3vil para reducir el ruido en la se\u00f1al.  </li> <li>Generar una se\u00f1al PWM de 50 Hz para controlar la posici\u00f3n del servomotor.  </li> <li>Convertir la lectura del ADC (0\u20134095) en un \u00e1ngulo de 0\u00b0 a 180\u00b0.  </li> <li>Calibrar la se\u00f1al PWM para producir pulsos entre 1 ms y 2 ms seg\u00fan el \u00e1ngulo.  </li> </ul>"},{"location":"ADC_servo/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"Componente GPIO Descripci\u00f3n Potenci\u00f3metro (salida central) 26 (ADC0) Entrada anal\u00f3gica Servomotor (se\u00f1al) 0 Salida PWM Alimentaci\u00f3n servo 5V (Vsys) Energ\u00eda para el motor GND com\u00fan \u2014 Tierra compartida <p>Notas de conexi\u00f3n: - Conectar el potenci\u00f3metro como divisor de voltaje entre 3.3V y GND. - La terminal central se conecta a GPIO26 (ADC0). - El servomotor se conecta al GPIO0 (PWM). - Asegurarse de compartir GND entre el servo y la Raspberry Pi Pico.  </p> <p>Esquema b\u00e1sico:</p>"},{"location":"ADC_servo/#4-codigo-principal","title":"4) C\u00f3digo principal","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n#include \"hardware/pwm.h\"\n\n#define ADC_INPUT 0\n#define N_muestras 16\n#define SERVO_PIN 0\n\nuint16_t angle_to_pwm(float angle) {\n    float pulse_ms = 1.0f + (angle / 180.0f);     // 1.0 \u2192 2.0 ms\n    float duty = (pulse_ms / 20.0f) * 39062.0f;   // 20 ms periodo total\n    return (uint16_t)duty;\n}\n\nint main() {\n    stdio_init_all();\n    adc_init();\n    adc_gpio_init(26);        // GPIO26 = ADC0\n    adc_select_input(ADC_INPUT);\n\n    uint16_t buffer[N_muestras];\n    int sum = 0;\n    uint8_t indice = 0;\n    uint8_t cuenta = 0;\n\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN);\n    pwm_set_clkdiv(slice, 64.0f);\n    pwm_set_wrap(slice, 39062);\n    pwm_set_enabled(slice, true);\n\n    while (true) {\n        uint16_t adc = adc_read();\n\n        if (cuenta &lt; N_muestras) {\n            buffer[indice] = adc;\n            sum += adc;\n            cuenta++;\n            indice++;\n        } else {\n            sum -= buffer[indice];\n            buffer[indice] = adc;\n            sum += adc;\n\n            indice++;\n            if (indice &gt;= N_muestras) indice = 0;\n\n            printf(\"Muestra:%u\\n\", adc);\n            printf(\"Suma:%u\\n\", sum);\n            printf(\"N_muestras:%u\\n\", N_muestras);\n\n            int promedio = sum / N_muestras;\n            int porcentaje = ((promedio * 180.0f) / 4200.0f);\n            porcentaje = porcentaje % 180;\n\n            printf(\"Promedio:%u\\n\", promedio);\n            printf(\"Porcentaje:%u\\n\", porcentaje);\n\n            if (porcentaje == 0) porcentaje = 1;\n            pwm_set_gpio_level(SERVO_PIN, angle_to_pwm(porcentaje));\n        }\n    }\n}\n</code></pre>"},{"location":"ADC_servo/#5-explicacion-del-codigo","title":"5) Explicaci\u00f3n del c\u00f3digo","text":""},{"location":"ADC_servo/#a-lectura-del-adc","title":"a) Lectura del ADC","text":"<ul> <li>El potenci\u00f3metro se conecta al pin GPIO26 (ADC0).  </li> <li>El ADC trabaja con una resoluci\u00f3n de 12 bits, entregando valores de <code>0</code> a <code>4095</code>.  </li> <li>Se inicializa con <code>adc_init()</code>, se asigna el pin con <code>adc_gpio_init(26)</code> y se selecciona el canal con <code>adc_select_input(ADC_INPUT)</code>.</li> </ul>"},{"location":"ADC_servo/#b-filtro-de-media-movil","title":"b) Filtro de media m\u00f3vil","text":"<ul> <li>Se usa un buffer circular de 16 muestras (<code>N_muestras = 16</code>) para suavizar la lectura del potenci\u00f3metro.  </li> <li>Cada vez que se obtiene una nueva lectura, se reemplaza la m\u00e1s antigua en el buffer y se recalcula la suma total.  </li> <li>El promedio (<code>promedio = sum / N_muestras</code>) reduce el ruido en la se\u00f1al, evitando movimientos bruscos en el servo.</li> </ul>"},{"location":"ADC_servo/#c-conversion-del-valor-adc-a-angulo","title":"c) Conversi\u00f3n del valor ADC a \u00e1ngulo","text":"<ul> <li>El valor promedio se convierte a un \u00e1ngulo entre 0\u00b0 y 180\u00b0 con la f\u00f3rmula:   [   \\text{\u00e1ngulo} = \\frac{\\text{promedio} \\times 180}{4200}   ]</li> <li>Esto garantiza una relaci\u00f3n proporcional entre el giro del potenci\u00f3metro y la posici\u00f3n del servomotor.  </li> <li>Si el valor calculado es 0, se corrige a 1\u00b0 para evitar pulsos nulos.</li> </ul>"},{"location":"ADC_servo/#d-generacion-de-senal-pwm","title":"d) Generaci\u00f3n de se\u00f1al PWM","text":"<ul> <li>Se configura el PWM en el pin GPIO0 (SERVO_PIN).  </li> <li>El ciclo de trabajo se ajusta con <code>pwm_set_gpio_level()</code> seg\u00fan el \u00e1ngulo calculado.  </li> <li>La funci\u00f3n <code>angle_to_pwm()</code> convierte el \u00e1ngulo a una se\u00f1al de pulso entre 1 ms (0\u00b0) y 2 ms (180\u00b0) dentro de un periodo total de 20 ms (50 Hz).  </li> <li>Se utilizan los par\u00e1metros:</li> <li><code>pwm_set_clkdiv(slice, 64.0f)</code> para dividir la frecuencia base.  </li> <li><code>pwm_set_wrap(slice, 39062)</code> para definir el periodo del pulso.  </li> </ul>"},{"location":"ADC_servo/#e-flujo-general-del-programa","title":"e) Flujo general del programa","text":"<ol> <li>Se leen continuamente los valores del potenci\u00f3metro.  </li> <li>Se filtran mediante la media m\u00f3vil.  </li> <li>Se calcula el \u00e1ngulo correspondiente.  </li> <li>Se ajusta el ancho del pulso PWM, moviendo el servo de forma proporcional y estable.  </li> <li>Se muestran en consola los valores de muestra, suma, promedio y \u00e1ngulo.</li> </ol>"},{"location":"ADC_servo/#6-resultados-esperados","title":"6) Resultados esperados","text":"<ul> <li>Al girar el potenci\u00f3metro, el servomotor rota suavemente de 0\u00b0 a 180\u00b0.  </li> <li>El sistema responde de forma estable, sin vibraciones gracias al filtro promedio.  </li> <li>En consola se muestran los valores de cada ciclo, facilitando la calibraci\u00f3n y depuraci\u00f3n.</li> </ul> <p>Ejemplo de salida en terminal: <pre><code>Muestra: 2100\nSuma: 33600\nN_muestras: 16\nPromedio: 2100\nPorcentaje: 90\n</code></pre> Resultado esperado: control suave y proporcional del servomotor basado en la posici\u00f3n del potenci\u00f3metro, demostrando una lectura anal\u00f3gica estable y conversi\u00f3n eficiente mediante PWM.</p>"},{"location":"Cafetera/","title":"cafetera","text":""},{"location":"Cafetera/#cafe-en-capsulas","title":"Caf\u00e9 en C\u00e1psulas","text":"<p>En esta presentaci\u00f3n exploraremos la evoluci\u00f3n y el impacto de las cafeteras de c\u00e1psulas. Revisaremos su origen hist\u00f3rico, el modelo de negocio que las hizo exitosas y c\u00f3mo han transformado los h\u00e1bitos de consumo de caf\u00e9 en hogares y oficinas. Tambi\u00e9n analizaremos sus principales ventajas y desventajas, los avances tecnol\u00f3gicos m\u00e1s recientes, y su penetraci\u00f3n en el mercado global. Finalmente, cerraremos con una reflexi\u00f3n sobre los retos que enfrenta este sistema, especialmente en t\u00e9rminos de sostenibilidad y costos, para entender por qu\u00e9 se ha convertido en un fen\u00f3meno tan relevante en la cultura del caf\u00e9. Descargar especificaci\u00f3n (PDF)</p>"},{"location":"ComUARTled/","title":"Comunicaci\u00f3n UART para prender un LED (Raspberry Pi Pico)","text":"<p>Este proyecto utiliza Comunicaci\u00f3n UART para comunicarse entre dos Raspberry Pi Pico 2. Su objetivo es presionar un bot\u00f3n conectado a una Raspberry y que \u00e9sta mande una se\u00f1al a la otra Raspberry para que prenda un LED. No conectar a la red el\u00e9ctrica.</p>"},{"location":"ComUARTled/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Prender un LED por comunicaci\u00f3n UART </li> <li>Equipo / Autor(es): Rodrigo Z\u00e1rate </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 12/10/2025 </li> <li>Descripci\u00f3n breve: Comunicaci\u00f3n serial UART entre dos Raspberry Pi Pico donde una act\u00faa como transmisor (env\u00eda datos al presionar un bot\u00f3n) y la otra como receptor (enciende un LED al recibir el dato). </li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>, <code>hardware/uart.h</code>, <code>hardware/gpio.h</code>). T\u00e9cnicas clave: Comunicaci\u00f3n UART as\u00edncrona, transmisi\u00f3n y recepci\u00f3n de bytes, control digital de GPIO. Plataforma: Raspberry Pi Pico / Pico 2.  </p>"},{"location":"ComUARTled/#material-utilizado","title":"Material utilizado","text":"<ul> <li>2 \u00d7 Raspberry Pi Pico (o Pico 2)  </li> <li>2 \u00d7 Cables USB  </li> <li>1 \u00d7 Bot\u00f3n (pushbutton)  </li> <li>1 \u00d7 Resistencia de 10 k\u03a9 (pull-down)  </li> <li>1 \u00d7 LED + resistencia de 330 \u03a9  </li> <li>Protoboard y jumpers macho-macho  </li> </ul>"},{"location":"ComUARTled/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar comunicaci\u00f3n UART entre dos Raspberry Pi Pico.  </li> <li>Programar un transmisor que env\u00ede un car\u00e1cter al presionar un bot\u00f3n.  </li> <li>Programar un receptor que encienda un LED al recibir el car\u00e1cter.  </li> <li>Implementar baud rate com\u00fan (9600 bps) para sincronizar ambas placas.  </li> <li>Verificar la correcta transmisi\u00f3n y recepci\u00f3n mediante el encendido del LED.</li> </ul>"},{"location":"ComUARTled/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>Mapeo de pines (seg\u00fan el c\u00f3digo):</p> Se\u00f1al Pico (TX) Pico (RX) Descripci\u00f3n <code>TX</code> GP0 \u2014 Transmisor UART <code>RX</code> \u2014 GP1 Receptor UART <code>GND</code> GND GND Tierra com\u00fan entre ambas placas <p>Entradas y salidas:</p> Dispositivo GPIO Funci\u00f3n Maestro (TX) 14 Bot\u00f3n de env\u00edo Esclavo (RX) 15 LED indicador <p>Notas de conexi\u00f3n: - Conectar GP0 (TX) del maestro a GP1 (RX) del esclavo. - Conectar GND a GND. - Usar resistencia 330 \u03a9 en serie con el LED. - Usar resistencia de 10 k\u03a9 pull-down en el bot\u00f3n.</p> <p>Diagrama de conexi\u00f3n </p>"},{"location":"ComUARTled/#4-codigo","title":"4) C\u00f3digo","text":""},{"location":"ComUARTled/#codigo-emisor","title":"Codigo emisor","text":"<pre><code>    #include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define button_pin 15\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    gpio_init(button_pin);\n    gpio_set_dir(button_pin, GPIO_IN);\n    gpio_pull_up(button_pin);\n    while (true){\n        if (gpio_get(button_pin) == 0) {\n            uart_puts(UART_ID, \"1\");\n            sleep_ms(10);\n        }\n        else {\n            uart_puts(UART_ID, \"0\");\n            sleep_ms(10);\n        }\n    }\n}\n</code></pre>"},{"location":"ComUARTled/#codigo-receptor","title":"Codigo receptor","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define led_PIN 15\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(uart0, BAUD_RATE);\n    uart_set_format(uart0, 8, 1, UART_PARITY_NONE);\n    gpio_init(led_PIN);\n    gpio_set_dir(led_PIN, GPIO_OUT);\n\n    printf(\"[SUPPORT] Esperando mensajes (polling)...\\n\");\n\n    while (true) {\n        if (uart_is_readable(uart0)) {\n            char c = uart_getc(uart0);\n            if (c == '1') {\n                gpio_put(led_PIN, 1);\n\n            } else {\n                gpio_put(led_PIN, 0);\n\n            } \n        }\n    }\n}\n</code></pre>"},{"location":"ComUARTled/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"ComUARTled/#a-comunicacion-uart","title":"a) Comunicacion UART","text":"<ul> <li>Se utiliza UART0 con Tx = GP0 y Rx = GP1.</li> <li>La comunicaci\u00f3n se realiza a 9600 bps, un valor estable para transmisi\u00f3n entre microcontroladores.</li> <li>El transmisor env\u00eda un car\u00e1cter ASCII ('A'), que el receptor interpreta para encender un LED.</li> </ul>"},{"location":"ComUARTled/#b-logica-del-transmisor","title":"b) L\u00f3gica del transmisor","text":"<ul> <li>El bot\u00f3n en GP14 env\u00eda 'A' por UART cuando se presiona.</li> <li>Usa sleep_ms(300) para evitar rebotes.</li> <li>Se transmite un solo byte por evento.</li> </ul>"},{"location":"ComUARTled/#c-logica-del-receptor","title":"c) L\u00f3gica del receptor","text":"<ul> <li>El receptor monitorea constantemente con uart_is_readable().</li> <li>Al recibir 'A', enciende el LED durante 500 ms.</li> <li>Esto confirma que la comunicaci\u00f3n UART funciona correctamente.</li> </ul>"},{"location":"ComUARTled/#d-consideraciones","title":"d) Consideraciones","text":"<ul> <li>Ambas Raspberry deben compartir GND com\u00fan.</li> <li>Si hay errores en transmisi\u00f3n, verificar la velocidad (baud rate).</li> <li>Se puede ampliar el sistema para enviar distintos caracteres y controlar m\u00e1s salidas.</li> </ul>"},{"location":"ComUARTled/#6-pruebas-y-comportamiento-esperado","title":"6) Pruebas y comportamiento esperado","text":"<ul> <li>Transmisor: Al presionar el bot\u00f3n, se env\u00eda el car\u00e1cter 'A'.</li> <li>Receptor: Enciende el LED al recibir 'A'.</li> <li>Verificaci\u00f3n: Si se desconecta GND, el LED no responde.</li> <li>Prueba adicional: Conectar el receptor a un monitor serial mostrar\u00e1 el car\u00e1cter recibido.</li> <li>Resultado esperado: Comunicaci\u00f3n confiable UART entre dos Raspberry Pi Pico, confirmada por el encendido del LED.</li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/","title":"Comparacion de sistemas embebidos para el desarrollo de una consola Gameboy:","text":""},{"location":"Comparacion_de_sistemas_embebidos/#1-esp32-esp32-s3","title":"1. ESP32 / ESP32-S3","text":"<ul> <li> <p>Precio: muy barato (5\u201315 USD).</p> </li> <li> </li> <li> </li> <li> <p>Ideal si quieres algo muy simple estilo Game Boy Classic o NES port\u00e1til.</p> </li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/#pros","title":"Pros:","text":"<ul> <li>Bajo consumo, perfecto para port\u00e1til con bater\u00eda.</li> <li>Soporta emulaci\u00f3n NES, Game Boy, Game Boy Color, Master System sin problemas.</li> <li>Much\u00edsimos proyectos DIY en GitHub (ej. Odroid-Go, ESP32 Game Boy clones).</li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/#contras","title":"Contras:","text":"<ul> <li>No suficiente potencia para SNES fluido o PS1.</li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/#2-odroid-go-advance-basado-en-rockchip-rk3326","title":"2. Odroid-Go Advance (basado en Rockchip RK3326)","text":"<p>Precio: unos 60\u201380 USD con kit completo.</p> <ul> <li>Ideal si quieres calidad/precio para algo ya m\u00e1s completo.</li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/#pros_1","title":"Pros:","text":"<ul> <li>Mucho m\u00e1s potente que un ESP32.</li> <li>Corre SNES, GBA, PS1 e incluso algo de N64 y PSP ligero.</li> <li>Pantalla, botones y bater\u00eda ya integrados (como una consola port\u00e1til DIY).</li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/#contras_1","title":"Contras:","text":"<ul> <li>No tan barato como un ESP32.</li> <li>Menos comunidad que Raspberry.</li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/#3-anbernic-powkiddy-consolas-chinas-retro-listas","title":"3. Anbernic / Powkiddy (consolas chinas retro listas)","text":"<ul> <li>Usan SoCs tipo Allwinner, Rockchip o Ingenic.</li> <li>Precio: 50\u2013120 USD.</li> <li> </li> <li> </li> <li>Ejemplos buenos: RG35XX Plus, Miyoo Mini Plus, RG353V.</li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/#pros_2","title":"Pros:","text":"<ul> <li>Ya vienen listas (pantalla, bater\u00eda, controles).</li> <li>Emulan de NES hasta PS1, Dreamcast y PSP seg\u00fan modelo.</li> <li>Calidad/precio insuperable si no quieres \u201csoldar y programar\u201d.</li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/#contras_2","title":"Contras:","text":"<ul> <li>No es DIY.</li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/#4-compute-modules-sbc-alternativos","title":"4. Compute Modules / SBC alternativos","text":"<ul> <li>Banana Pi, Orange Pi, Rock Pi, Radxa.</li> <li> </li> <li> </li> <li>\u00datiles si quieres un \u201cmini-PC\u201d emulador sin pagar sobreprecio de Raspberry.</li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/#pros_3","title":"Pros:","text":"<ul> <li>similares a Raspberry Pi, a veces m\u00e1s potentes y m\u00e1s baratos.</li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/#contras_3","title":"Contras:","text":"<ul> <li>menos documentaci\u00f3n y comunidad.</li> </ul>"},{"location":"Comparacion_de_sistemas_embebidos/#tabla-comparativa","title":"Tabla Comparativa","text":"Plataforma / Chip CPU Velocidad (GHz) RAM Almacenamiento Rendimiento en emulaci\u00f3n ESP32-S3 2\u00d7 Xtensa LX7 240 MHz 512 KB SRAM interna + hasta 8 MB PSRAM externa MicroSD NES, GB, GBC, SMS muy bien; SNES limitado Raspberry Pi Zero 2 W Quad-core ARM Cortex-A53 1.0 GHz 512 MB LPDDR2 MicroSD NES, GB, SNES, GBA bien; PS1 justo Raspberry Pi 3B+ Quad-core ARM Cortex-A53 1.4 GHz 1 GB LPDDR2 MicroSD SNES perfecto, GBA bien, PS1 fluido Raspberry Pi 4B Quad-core ARM Cortex-A72 1.5\u20131.8 GHz (OC) 2\u20138 GB LPDDR4 MicroSD / SSD SNES, GBA, PS1 perfecto; N64 y PSP jugable (no todo) Odroid-Go Advance (RK3326) Quad-core ARM Cortex-A35 1.3 GHz 1 GB LPDDR3 MicroSD NES\u2192PS1 muy bien; N64 y PSP con l\u00edmites Anbernic RG35XX Plus (Allwinner H700) Quad-core Cortex-A53 1.5 GHz 1 GB LPDDR4 MicroSD NES\u2192PS1 perfecto; GBA excelente; N64 parcial"},{"location":"Comunicacion_I2C/","title":"Comunicaci\u00f3n I2C con DS1307 (Reloj) y MPU6050 (Aceler\u00f3metro) \u2013 Raspberry Pi Pico","text":"<p>Este proyecto establece comunicaci\u00f3n I2C doble con dos dispositivos diferentes usando dos puertos I2C del Raspberry Pi Pico: - Un DS1307 (reloj de tiempo real, RTC) para leer hora, minuto y segundo. - Un MPU6050 para leer la aceleraci\u00f3n en los ejes X, Y y Z.  </p>"},{"location":"Comunicacion_I2C/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Lectura de RTC DS1307 y aceler\u00f3metro MPU6050 por I2C </li> <li>Autor: Rodrigo Z\u00e1rate </li> <li>Asignatura: Sistemas Embebidos </li> <li>Fecha: 11/11/2025 </li> <li>Descripci\u00f3n breve: Uso de los dos puertos I2C del Raspberry Pi Pico para leer en paralelo la hora actual desde un DS1307 y la aceleraci\u00f3n en los tres ejes desde un MPU6050, mostrando los datos en la consola serie.</li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>, <code>hardware/i2c.h</code>) T\u00e9cnicas clave: Comunicaci\u00f3n I2C, conversi\u00f3n BCD\u2013decimal, lectura de registros, procesamiento de datos de aceler\u00f3metro. Plataforma: Raspberry Pi Pico / Pico 2  </p>"},{"location":"Comunicacion_I2C/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar dos puertos I2C del Raspberry Pi Pico (<code>i2c0</code> e <code>i2c1</code>).  </li> <li>Leer la hora desde el m\u00f3dulo de reloj DS1307.  </li> <li>Leer la aceleraci\u00f3n en X, Y y Z desde el sensor MPU6050.  </li> <li>Convertir datos en formato BCD a decimal para el reloj.  </li> <li>Convertir datos crudos del aceler\u00f3metro a unidades de g.  </li> <li>Mostrar toda la informaci\u00f3n en la consola serie cada segundo.</li> </ul>"},{"location":"Comunicacion_I2C/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"Dispositivo Puerto I2C GPIO SDA GPIO SCL Direcci\u00f3n I2C DS1307 (RTC) I2C0 GP4 GP5 <code>0x68</code> MPU6050 (Aceler\u00f3metro) I2C1 GP2 GP3 <code>0x68</code> <p>Notas de conexi\u00f3n: - Ambos dispositivos usan la misma direcci\u00f3n (<code>0x68</code>), pero est\u00e1n en puertos I2C diferentes, por eso no hay conflicto. - Conectar VCC del DS1307 y MPU6050 a 3.3V o 5V (seg\u00fan el m\u00f3dulo, muchos traen regulador). - Conectar GND com\u00fan entre Pico, DS1307 y MPU6050. - En muchos m\u00f3dulos ya vienen resistencias pull-up en SDA/SCL; si no, usar resistencias de 4.7 k\u03a9 a 3.3 V.  </p>"},{"location":"Comunicacion_I2C/#esquematico","title":"Esquematico","text":""},{"location":"Comunicacion_I2C/#4-codigo-principal","title":"4) C\u00f3digo principal","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/i2c.h\"\n\n#define I2C_PORT    i2c0       // DS1307\n#define I2C_PORTA   i2c1       // MPU6050\n#define SDA_PINR    4\n#define SCL_PINR    5\n#define SDA_PINA    2\n#define SCL_PINA    3\n\n#define ADDR  0x68   // Direcci\u00f3n DS1307\n#define ADDRA 0x68   // Direcci\u00f3n MPU6050\n\nstatic inline uint8_t bcd2dec(uint8_t v) {\n    return (uint8_t)((v &gt;&gt; 4) * 10 + (v &amp; 0x0F));\n}\n\nstatic inline int16_t make16(uint8_t hi, uint8_t lo) {\n    return (int16_t)((hi &lt;&lt; 8) | lo);\n}\n\nint main(void) {\n    stdio_init_all();\n\n    i2c_init(I2C_PORT, 100000);\n    i2c_init(I2C_PORTA, 100000);\n\n    gpio_set_function(SDA_PINR, GPIO_FUNC_I2C);\n    gpio_set_function(SCL_PINR, GPIO_FUNC_I2C);\n    gpio_set_function(SDA_PINA, GPIO_FUNC_I2C);\n    gpio_set_function(SCL_PINA, GPIO_FUNC_I2C);\n\n    gpio_pull_up(SDA_PINR);\n    gpio_pull_up(SCL_PINR);\n    gpio_pull_up(SDA_PINA);\n    gpio_pull_up(SCL_PINA);\n\n    sleep_ms(500);\n\n    while (true) {\n        // ---------- Lectura del DS1307 (Reloj) ----------\n        uint8_t regR = 0x00;     // Registro de segundos\n        uint8_t memoriaR[3];     // seg, min, hour\n\n        int wR = i2c_write_blocking(I2C_PORT, ADDR, &amp;regR, 1, true);\n        if (wR &lt; 0) {\n            printf(\"I2C R error (ret=%d)\\n\", wR);\n        } else if (wR != 1) {\n            printf(\"R Escritura parcial: %d/1 bytes\\n\", wR);\n        } else {\n            int rR = i2c_read_blocking(I2C_PORT, ADDR, memoriaR, sizeof(memoriaR), false);\n            if (rR &lt; 0) {\n                printf(\"I2C R error (ret=%d)\\n\", rR);\n            } else if (rR != (int)sizeof(memoriaR)) {\n                printf(\"R Lectura parcial: %d/%d bytes\\n\", rR, (int)sizeof(memoriaR));\n            } else {\n                uint8_t seg_bcd  = memoriaR[0];\n                uint8_t min_bcd  = memoriaR[1];\n                uint8_t hour_raw = memoriaR[2];\n\n                uint8_t seg  = bcd2dec(seg_bcd);\n                uint8_t min  = bcd2dec(min_bcd);\n                uint8_t hour = bcd2dec(hour_raw);\n\n                printf(\"Reloj = %02u:%02u:%02u\\n\", hour, min, seg);\n            }\n        }\n\n        // ---------- Lectura del MPU6050 (Aceler\u00f3metro) ----------\n        uint8_t regA = 0x3B;     // Primer registro de aceleraci\u00f3n\n        uint8_t memoriaA[6];     // AX, AY, AZ (2 bytes cada uno)\n\n        int wA = i2c_write_blocking(I2C_PORTA, ADDRA, &amp;regA, 1, true);\n        if (wA &lt; 0) {\n            printf(\"I2C A error (ret=%d)\\n\", wA);\n        } else if (wA != 1) {\n            printf(\"A Escritura parcial: %d/1 bytes\\n\", wA);\n        } else {\n            int rA = i2c_read_blocking(I2C_PORTA, ADDRA, memoriaA, sizeof(memoriaA), false);\n            if (rA &lt; 0) {\n                printf(\"I2C A error (ret=%d)\\n\", rA);\n            } else if (rA != (int)sizeof(memoriaA)) {\n                printf(\"A Lectura parcial: %d/%d bytes\\n\", rA, (int)sizeof(memoriaA));\n            } else {\n                int16_t ax_raw = make16(memoriaA[0], memoriaA[1]);\n                int16_t ay_raw = make16(memoriaA[2], memoriaA[3]);\n                int16_t az_raw = make16(memoriaA[4], memoriaA[5]);\n\n                const float scale = 16384.0f; // \u00b12g\n                float ax_g = (float)ax_raw / scale;\n                float ay_g = (float)ay_raw / scale;\n                float az_g = (float)az_raw / scale;\n\n                printf(\"Aceleracion = X: %.3fg  Y: %.3fg  Z: %.3fg\\n\",\n                       ax_g, ay_g, az_g);\n            }\n        }\n\n        sleep_ms(1000);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Comunicacion_I2C/#5-explicacion-del-codigo","title":"5) Explicaci\u00f3n del c\u00f3digo","text":""},{"location":"Comunicacion_I2C/#a-configuracion-de-los-puertos-i2c","title":"a) Configuraci\u00f3n de los puertos I2C","text":"<ul> <li>Se utilizan dos interfaces I2C del Raspberry Pi Pico:</li> <li><code>i2c0</code> para el DS1307 (reloj de tiempo real).</li> <li><code>i2c1</code> para el MPU6050 (aceler\u00f3metro).</li> <li>Ambas se inicializan con una frecuencia de 100 kHz usando <code>i2c_init()</code>.</li> <li>Los pines asignados son:</li> <li>I2C0: SDA en GP4, SCL en GP5.</li> <li>I2C1: SDA en GP2, SCL en GP3.</li> <li>Cada l\u00ednea I2C cuenta con resistencias de pull-up activadas con <code>gpio_pull_up()</code>.</li> </ul>"},{"location":"Comunicacion_I2C/#b-conversion-de-formatos","title":"b) Conversi\u00f3n de formatos","text":"<ul> <li>El reloj DS1307 entrega los valores en formato BCD (Binary-Coded Decimal).</li> <li>La funci\u00f3n auxiliar <code>bcd2dec()</code> convierte el valor a decimal dividiendo las decenas y unidades.</li> <li>Para el MPU6050, los valores de aceleraci\u00f3n vienen en dos bytes (alto y bajo).   La funci\u00f3n <code>make16()</code> une ambos para formar un entero de 16 bits con signo.</li> </ul>"},{"location":"Comunicacion_I2C/#c-lectura-del-ds1307-reloj","title":"c) Lectura del DS1307 (Reloj)","text":"<ol> <li>Se selecciona el registro inicial <code>0x00</code> para comenzar a leer desde los segundos.  </li> <li>Se leen tres bytes correspondientes a segundos, minutos y horas.  </li> <li>Cada valor se convierte de BCD a decimal mediante <code>bcd2dec()</code>.  </li> <li>Finalmente se imprime la hora en el formato <code>hh:mm:ss</code>:    <pre><code>printf(\"Reloj = %02u:%02u:%02u\\n\", hour, min, seg);\n</code></pre></li> </ol>"},{"location":"Comunicacion_I2C/#d-lectura-del-mpu6050-acelerometro","title":"d) Lectura del MPU6050 (Aceler\u00f3metro)","text":"<ol> <li>Se selecciona el registro <code>0x3B</code>, donde comienzan los datos de aceleraci\u00f3n.  </li> <li>Se leen 6 bytes: dos para cada eje (X, Y, Z).  </li> <li>Los valores se convierten con <code>make16()</code> y se escalan a unidades de g usando <code>1g = 16384 LSB</code>.  </li> <li>Los datos se muestran as\u00ed:    <pre><code>printf(\"Aceleracion = X: %.3fg  Y: %.3fg  Z: %.3fg\\n\", ax_g, ay_g, az_g);\n</code></pre></li> </ol>"},{"location":"Comunicacion_I2C/#e-bucle-principal","title":"e) Bucle principal","text":"<ul> <li>Dentro de <code>while(true)</code>, se ejecutan las lecturas del reloj y el aceler\u00f3metro continuamente.  </li> <li>Cada ciclo espera 1 segundo con <code>sleep_ms(1000)</code> para actualizar los valores.  </li> <li>Si ocurre un error I2C, el programa lo reporta en la consola mediante mensajes de depuraci\u00f3n.</li> </ul>"},{"location":"Comunicacion_I2C/#6-resultados","title":"6) Resultados","text":"<ul> <li>En la consola serie aparecer\u00e1n l\u00edneas como las siguientes:   <pre><code>Reloj = 14:25:31\nAceleracion = X: 0.010g  Y: -0.045g  Z: 0.998g\n</code></pre></li> <li>El reloj DS1307 mostrar\u00e1 la hora actual avanzando segundo a segundo.  </li> <li>El MPU6050 reflejar\u00e1 los cambios de aceleraci\u00f3n al mover o inclinar el sensor.  </li> <li>En reposo, los valores t\u00edpicos ser\u00e1n:</li> <li>X \u2248 0 g  </li> <li>Y \u2248 0 g  </li> <li>Z \u2248 1 g </li> </ul>"},{"location":"CreandoValor/","title":"Creando Valor","text":""},{"location":"CreandoValor/#1-la-oferta-que-quiere-la-gente","title":"1) La oferta: \u00bfqu\u00e9 quiere la gente?","text":"<p>Rango de productos (oferta) \u2022   RANA Go (MVP) \u2014 Robot de limpieza con navegaci\u00f3n asistida (teleoperado con ayudas de rumbo y anticolisi\u00f3n), skimmer para s\u00f3lidos flotantes, filtro fino y telemetr\u00eda b\u00e1sica (turbidez, temperatura).</p> <p>\u2022   RANA Pro \u2014 Semi-aut\u00f3nomo con rutas guiadas, geocercas, detecci\u00f3n de obst\u00e1culos (LiDAR/c\u00e1mara/US), mapas de calor de basura y reportes autom\u00e1ticos para cumplimiento (antes/despu\u00e9s, kg recogidos, horas de operaci\u00f3n).</p> <p>\u2022   RANA Fleet \u2014 Coordinaci\u00f3n multi-robot, panel web para planear jornadas, API para municipios/operadoras de parques y SLAs de mantenimiento.</p> <p>\u2022   Servicios complementarios: estudio inicial (l\u00ednea base de contaminaci\u00f3n), mantenimiento preventivo, retiro y disposici\u00f3n certificada, suscripci\u00f3n de monitoreo ambiental (turbidez, pH, DO, clorofila, cianobacterias opcional).</p> <p>Segmentos objetivo (targeted) 1.  Municipios y organismos de agua (lagos urbanos, canales). 2.  Administradores de parques y clubs n\u00e1uticos (imagen p\u00fablica, seguridad sanitaria). 3.  Hoteles y marinas privadas (experiencia del visitante). 4.  Universidades/labs ambientales (datos y campo).</p>"},{"location":"CreandoValor/#2-propuesta-de-valor","title":"2) Propuesta de valor","text":"<p>\u2022   Dolores reales: limpieza manual costosa e intermitente; quejas vecinales por mal olor/algas; falta de datos verificables para justificar presupuesto.</p> <p>\u2022   Ganancias: limpieza m\u00e1s frecuente y segura, evidencia cuantificada para reportes y decisiones, operaci\u00f3n silenciosa y con bajo OPEX. \u00daNICA (Unique)</p> <p>\u2022   Navegaci\u00f3n asistida: combina control humano con ayudas inteligentes (mantener rumbo, evitar colisiones, \u201climpia-en-ruta\u201d optimizada).</p> <p>\u2022   Data-first: reportes con kg/hora, m\u00b2 cubiertos, turbidez y mapas de calor \u2192 justifica inversi\u00f3n y muestra impacto.</p> <p>\u2022   Modular: skimmer, microalga boom, micro-dragado ligero, sensor pack opcional. DIRIGIDA (Targeted)</p> <p>\u2022   \u201cPeque\u00f1os-medianos cuerpos de agua urbanos (1\u201350 ha) con basura flotante recurrente y presi\u00f3n social por imagen/olores\u201d, responsable: Direcci\u00f3n de Parques/Servicios P\u00fablicos.</p>"},{"location":"CreandoValor/#3-producto-concreto-para-el-primer-prototipo","title":"3) Producto concreto (para el primer prototipo)","text":"<p>\u2022   RANA Go (MVP) con: o   Chasis el\u00e9ctrico IP-rated, tiempo de operaci\u00f3n 3\u20134 h.</p> <p>o   Ayudas de navegaci\u00f3n: estabilizaci\u00f3n de rumbo, \u201cretorno seguro\u201d, frenado por proximidad.</p> <p>o   Skimmer + canastilla medible (hasta 20\u201330 kg/d\u00eda).</p> <p>o   Telemetr\u00eda en app web: m\u00b2 barridos, kg estimados (celdas de carga o conteo por volumen), turbidez, ruta GPS simple.</p>"},{"location":"CreandoValor/#creando-valor-rana-robot-acuatico-de-navegacion-asistida","title":"Creando Valor \u2014 RANA (Robot Acu\u00e1tico de Navegaci\u00f3n Asistida)","text":"INSIGHTFUL (Necesidades reales) UNIQUE (Dif\u00edcil de replicar) TARGETED (Cliente apasionado) Limpieza frecuente y segura de lagos/canales urbanos. Navegaci\u00f3n asistida: rumbo estable, retorno seguro y *anticolisi\u00f3n. *Municipios/organismos de agua con presi\u00f3n por quejas vecinales. Indicadores cuantificables para justificar presupuesto (kg de residuos, m\u00b2 cubiertos, turbidez reducida). Operaci\u00f3n data-first con reportes autom\u00e1ticos y mapas de calor de basura. Direcciones de Parques/Servicios P\u00fablicos responsables de imagen y sanidad. Respuesta r\u00e1pida post-lluvias y en temporadas altas de residuos. Arquitectura modular (skimmer, sensores, micro-dragado) seg\u00fan sitio. Marinas/hoteles que cuidan la experiencia visual del visitante. Servicio integral: recolecci\u00f3n + disposici\u00f3n y mantenimiento con OPEX bajo. Pilotos en 1 semana (despliegue \u00e1gil) + panel web/API para gesti\u00f3n y trazabilidad. Universidades/labs ambientales que requieren campa\u00f1as de monitoreo con evidencia."},{"location":"ElMercado/","title":"El Mercado","text":""},{"location":"ElMercado/#1-el-mercado","title":"1) El mercado","text":"<p>Definici\u00f3n del mercado (problema + qui\u00e9n paga + por qu\u00e9 ahora):</p> <p>Problema: Residuos flotantes (pl\u00e1stico, unicel, hojas) en marinas, lagos, r\u00edos, canales urbanos y presas; altos costos y riesgos del retiro manual; mala imagen tur\u00edstica; multas regulatorias posibles.</p> <p>Cliente que paga: Ayuntamientos/organismos de agua y limpia, marinas privadas, puertos, parques industriales con lagunas de retenci\u00f3n, hoteles/resorts con frente de agua, ONGs y organizadores de eventos de limpieza.</p> <p>Job-to-be-done: Mantener espejos de agua visiblemente limpios con coste predecible, seguridad y trazabilidad (kg recolectados/semana).</p> <p>Propuesta de valor (PV): Robot aut\u00f3nomo/teleoperado que recoge basura flotante de forma continua con una red frontal, reduce costos operativos, mejora la seguridad (menos personal en lanchas), y proporciona datos (mapa/calendario de residuos).</p> <p>Tama\u00f1o de mercado (m\u00e9todo TAM\u2013SAM\u2013SOM):</p> <p>TAM (Top-down o bottom-up): #cuerpos de agua x gasto anual promedio en limpieza.</p> <p>SAM: sub-conjunto accesible (p. ej., cuerpos de agua urbanos/navegables en tu pa\u00eds o regi\u00f3n).</p> <p>SOM (12\u201324 meses): contratos que puedes realmente cerrar con tu capacidad de producci\u00f3n. Plantilla r\u00e1pida (reemplaza \u201cX\u201d con tus cifras reales):</p> <p>TAM \u2248 (X municipios con cuerpos de agua urbanos + X marinas/puertos + X parques industriales) \u00d7 (USD X mil/a\u00f1o en limpieza).</p> <p>SAM \u2248 (ciudades costeras + capitales estatales + marinas tur\u00edsticas) \u00d7 (USD X mil/a\u00f1o).</p> <p>SOM \u2248 (# pilotos confirmables en 1 a\u00f1o) \u00d7 (ticket medio).</p> <p>Clave del PDF: el tama\u00f1o del mercado depende de quienes tienen la necesidad y recursos para intercambiar (presupuesto) \u2014 no de la belleza t\u00e9cnica del producto. </p> <p>El mercado</p>"},{"location":"ElMercado/#2-de-la-solucion-tecnica-a-la-oportunidad-de-mercado","title":"2) De la soluci\u00f3n t\u00e9cnica a la oportunidad de mercado","text":"<p>Evitar la trampa \u201cproducto-soluci\u00f3n\u201d: no construyas \u201cporque se puede\u201d; gu\u00eda el dise\u00f1o por los requisitos de operaci\u00f3n que el cliente valida:</p> <p>Entrevistas Discovery (m\u00edn. 15): jefes de limpia, administradores de marinas, directores de medio ambiente.</p> <p>Hip\u00f3tesis que debes validar en campo:</p> <p>Caudal de basura (kg/d\u00eda) y tama\u00f1o t\u00edpico (bolsas, botellas, unicel, ramas).</p> <p>Condiciones de operaci\u00f3n: corrientes, oleaje, profundidad, zonas con lirio/alga.</p> <p>Restricciones: ruido, horario, fauna, tr\u00e1fico de embarcaciones, permisos.</p> <p>KPI de \u00e9xito del cliente: \u201c% superficie limpia antes de 10am\u201d, \u201ckg retirados/semana\u201d, \u201cincidentes=0\u201d.</p> <p>Modelo de contrataci\u00f3n preferido: compra CAPEX vs RaaS (Robotics-as-a-Service mensual).</p> <p>MVP dirigido por m\u00e9tricas: ancho de boca de red, autonom\u00eda (h), velocidad (km/h), capacidad (L/kg), filtrado de micro-residuos opcional.</p> <p>Enfoque del material: unir habilidades t\u00e9cnicas con entendimiento profundo del mercado y usar el an\u00e1lisis de mercado como pilar del desarrollo \u00e1gil. </p> <p>El mercado</p>"},{"location":"ElMercado/#3-ecosistema-segmentacion-del-mercado","title":"3) Ecosistema (Segmentaci\u00f3n del mercado)","text":"<p>Segmenta m\u00e1s all\u00e1 de la demograf\u00eda \u2014 geogr\u00e1fica, psicogr\u00e1fica y comportamental. </p> <p>El mercado</p>"},{"location":"ElMercado/#a-geografica","title":"A) Geogr\u00e1fica","text":"<p>Urbanos con canales/lagos (CDMX, GDL, MTY-canales, capitales estatales).</p> <p>Costero-tur\u00edstico (marinas, malecones, playas con esteros).</p> <p>Industrial (lagunas de retenci\u00f3n, parques log\u00edsticos).</p>"},{"location":"ElMercado/#b-demografica-institucionempresa","title":"B) Demogr\u00e1fica (instituci\u00f3n/empresa)","text":"<p>Municipios 100k\u20131M hab., marinas con &gt;100 posiciones, hoteles 4\u20135\u2605 con frente de agua.</p>"},{"location":"ElMercado/#c-psicografica","title":"C) Psicogr\u00e1fica","text":"<p>Entidades con orientaci\u00f3n a sostenibilidad, reputaci\u00f3n e indicadores ESG; organizaciones que comunican limpieza del frente de agua a turistas/vecinos.</p>"},{"location":"ElMercado/#d-comportamental","title":"D) Comportamental","text":"<p>Alta frecuencia de limpieza (diaria/semana), sensibles a queja ciudadana y beneficios buscados: seguridad, trazabilidad, costo fijo, imagen p\u00fablica.</p> <p>ICP (Ideal Customer Profile) + Personas (r\u00e1pido):</p> <p>ICP Municipio costero A: presupuesto medioambiental estable, quejas por basura post-lluvia, disposici\u00f3n a piloto 90 d\u00edas.</p> <p>Persona Decisor: Director de Servicios P\u00fablicos; Dolor: cuadrillas costosas y riesgos; \u00c9xito: superficies limpias antes de horario tur\u00edstico; Objeci\u00f3n: \u201c\u00bfY si se atora con lirio?\u201d \u2192 Mitigaci\u00f3n: parrilla anti-enganches + protocolo de reversa.</p>"},{"location":"ElMercado/#4-analisis-de-la-competencia","title":"4) An\u00e1lisis de la competencia","text":"<p>Sustitutos y rivales:</p> <p>Manual: brigadas con redes/lanchas (bajo CAPEX, alto OPEX/accidentes).</p> <p>Embarcaciones skimmer/booms fijos: buen caudal en puntos concretos, menor cobertura distribuida.</p> <p>Otros robots recolectores: soluciones aut\u00f3nomas con canastas/booms; pueden requerir muelles, tolerancia limitada a residuos grandes.</p> <p>No-consumo (dejarlo sucio): riesgo reputacional y sanciones.</p> <p>Matriz competitiva (llena con tus mediciones):</p> <p>Criterio    T\u00fa (Red frontal)    Manual  Skimmer fijo    Robot tipo-canasta Cobertura (m\u00b2/h)               Tama\u00f1o residuo m\u00e1x.            Autonom\u00eda (h)              OPEX mensual               Seguridad              Trazabilidad (kg/logs)              </p> <p>Posicionamiento: \u201cLimpieza distribuida y continua con coste predecible y datos en tiempo real; seguro para personal y fauna\u201d.</p>"},{"location":"ElMercado/#5-requisitos-de-compra-y-go-to-market","title":"5) Requisitos de compra y Go-to-Market","text":"<p>Pruebas piloto (60\u201390 d\u00edas): contrato de piloto con KPIs (kg/semana, % superficie limpia, horas de uptime).</p> <p>RaaS mensual con SLA: incluye equipo, mantenimiento, consumibles de red, reportes.</p> <p>Alianzas: ONGs de limpieza, marinas, aseguradoras (riesgos), universidades (monitoreo).</p> <p>Permisos y operaci\u00f3n: coordinaci\u00f3n con capitan\u00edas/autoridades de agua; capacitaci\u00f3n a operadores.</p> <p>Estrategia de entrada: prioriza 3 ciudades con \u201cdolor\u201d agudo post-lluvias; genera casos de \u00e9xito con video + dashboard.</p>"},{"location":"ElMercado/#6-modelo-de-negocio-y-precio-plantilla","title":"6) Modelo de negocio y precio (plantilla)","text":"<p>Opciones:</p> <p>Venta (CAPEX): Robot + kit de redes + docking. Ingreso \u00fanico + contrato de mantenimiento anual.</p> <p>RaaS (OPEX): cuota mensual por m\u00b2 de espejo de agua + horas de operaci\u00f3n.</p> <p>H\u00edbrido: fee de activaci\u00f3n + mensualidad menor.</p> <p>Unidad econ\u00f3mica (rellena con tus costos reales):</p> <p>Costo de fabricaci\u00f3n (BoM + mano de obra): $___</p> <p>Servicio/mes (operador, mantenimiento, traslados): $___</p> <p>Precio RaaS/mes objetivo: $___</p> <p>Margen bruto = (Precio \u2013 Costo servicio)/Precio</p> <p>Payback CAPEX del cliente (meses) = CAPEX actual de limpieza / Ahorro mensual esperado</p>"},{"location":"ElMercado/#7-metricas-lo-que-tu-cliente-quiere-ver","title":"7) M\u00e9tricas (lo que tu cliente quiere ver)","text":"<p>Impacto ambiental: kg/mes recolectados, tipolog\u00eda (pl\u00e1stico, org\u00e1nico), mapa de calor.</p> <p>Servicio: uptime %, tiempo medio entre atascos, tiempo de respuesta mantenimiento.</p> <p>Finanzas del cliente: costo por m\u00b2 limpio, costo por kg retirado vs. m\u00e9todo previo.</p>"},{"location":"ElMercado/#8-riesgos-y-mitigaciones","title":"8) Riesgos y mitigaciones","text":"<p>Lirio/alga masiva: dise\u00f1o de boca con parrilla + modo \u201cdesatasco\u201d (reversa/levanta-red).</p> <p>Fauna/aves: limitador de velocidad + parachoques blando + horario de operaci\u00f3n.</p> <p>Basura grande (troncos): sensor de par/obst\u00e1culo + bypass manual.</p> <p>Clima: plan operativo por temporada de lluvias; anclaje/almacenamiento seguro.</p> <p>Procura p\u00fablica lenta: alternativa RaaS a trav\u00e9s de organismos/ONGs o asociaciones p\u00fablico-privadas.</p>"},{"location":"Examen2/","title":"Control de Servo con Lista de \u00c1ngulos (UART + Botones)","text":"<p>Sistema que permite cargar una lista de \u00e1ngulos para un servo (0\u2013180\u00b0) mediante consola/serial, reproducirlos autom\u00e1ticamente o navegarlos con botones. No conectar a la red el\u00e9ctrica. El servo debe alimentarse a 5\u20136 V y compartir GND con la Pico/Pico 2.</p>"},{"location":"Examen2/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Lista de \u00e1ngulos para servo por UART y botones </li> <li>Equipo / Autor(es): Rodrigo Z\u00e1rate </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 22/10/2025 </li> <li>Descripci\u00f3n breve: La Pico 2 recibe comandos por consola/serial para \u201cEscribir\u201d una lista de \u00e1ngulos del servo. Con un bot\u00f3n se cambian los modos (Escritura / Lectura / Navegaci\u00f3n) y con otros dos botones se avanza/retrocede entre \u00e1ngulos en Navegaci\u00f3n. El PWM se configura a ~50 Hz.</li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>, <code>hardware/uart.h</code>, <code>hardware/pwm.h</code>, <code>hardware/gpio.h</code>). T\u00e9cnicas clave: Parsing sobre stdio (consola), PWM a 50 Hz para servo, GPIO con interrupci\u00f3n para cambio de modo. Plataforma: Raspberry Pi Pico / Pico 2. Baud rate: 115200 bps.  </p>"},{"location":"Examen2/#material-utilizado","title":"Material utilizado","text":"<ul> <li>1 \u00d7 Raspberry Pi Pico (o Pico 2)  </li> <li>1 \u00d7 Servo est\u00e1ndar (5\u20136 V)  </li> <li>3 \u00d7 Botones (pushbutton)  </li> <li>3 \u00d7 Resistencias (si no usas pull-ups internas)  </li> <li>Jumpers, protoboard  </li> <li>Fuente 5\u20136 V para servo (compartir GND con la Pico)  </li> <li>Cable USB (consola/serial por USB)</li> </ul>"},{"location":"Examen2/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar PWM ~50 Hz para controlar un servo por ancho de pulso (1.0\u20132.0 ms \u2194 0\u2013180\u00b0).  </li> <li>Implementar tres modos:  </li> <li>Modo 0 \u2013 Escritura: cargar lista de \u00e1ngulos desde consola.  </li> <li>Modo 1 \u2013 Lectura: reproducir toda la lista autom\u00e1ticamente.  </li> <li>Modo 2 \u2013 Navegaci\u00f3n: avanzar/retroceder por la lista con botones.  </li> <li>Dise\u00f1ar un protocolo sencillo de texto: <code>Escribir,&lt;a1&gt;,&lt;a2&gt;,...,&lt;an&gt;;</code> y <code>Borrar;</code>.</li> </ul>"},{"location":"Examen2/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>Mapeo de pines (seg\u00fan el c\u00f3digo):</p> Se\u00f1al / Dispositivo GPIO Funci\u00f3n UART0 TX GP0 TX hardware UART0 RX GP1 RX hardware Bot\u00f3n Modo GP16 Cambia <code>programa</code> (0\u21921\u21922\u21920) Bot\u00f3n Siguiente GP17 Avanza en Modo Navegaci\u00f3n Bot\u00f3n Anterior GP18 Retrocede en Modo Navegaci\u00f3n Servo (PWM) GP15 Se\u00f1al PWM (50 Hz) <p>Notas de conexi\u00f3n: - Los botones usan pull-ups internas (<code>gpio_pull_up</code>).   Con\u00e9ctalos de GPIO \u2192 Bot\u00f3n \u2192 GND (activo-bajo). - Servo: Se\u00f1al a GP15, +5\u20136 V a Vcc del servo, GND com\u00fan con la Pico. - Si usas UART f\u00edsico, respeta 115200 bps y GND com\u00fan.  </p> <p>Diagrama general (texto): <code>[Bot\u00f3n Modo GP16] [Bot\u00f3n Next GP17] [Bot\u00f3n Prev GP18] \u2192 Pico</code> <code>Pico GP15 PWM \u2192 Servo (se\u00f1al)</code> \u2014 <code>Servo Vcc 5\u20136 V</code> \u2014 <code>GND com\u00fan</code></p>"},{"location":"Examen2/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n#include \"hardware/pwm.h\"\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define btn_mode 16\n#define btn_next 17\n#define btn_prev 18\n#define PWM_PIN 0\n#define SERVO_PIN 15\nusing namespace std;\n#define list 10\n\nvolatile int programa = 0;\n\nuint16_t angle_to_pwm(float angle) {\n    float pulse_ms = 1.0f + (angle / 180.0f);   // 1.0 \u2192 2.0 ms\n    float duty = (pulse_ms / 20.0f) * 39062.0f; // 20 ms periodo total\n    return (uint16_t)duty;\n}\n\n// --- Rutina de interrupci\u00f3n ---\nstatic void button_isr(uint gpio, uint32_t events) {\n    if (gpio == btn_mode &amp;&amp; (events &amp; GPIO_IRQ_EDGE_FALL)) {\n        programa++;\n        if (programa &gt; 2) {\n            programa = 0;\n        }\n        if (programa == 0) {\n            printf(\"Modo de Escritura Activado\\n\");\n        } else if (programa == 1) {\n            printf(\"Modo de Lectura Activado\\n\");\n        } else if (programa == 2) {\n            printf(\"Modo de Navegacion Activado\\n\");\n        }\n        sleep_ms(500);\n    }\n}\n\nint main() {\n    int pos = 0;\n    stdio_init_all();\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN);\n    pwm_set_clkdiv(slice, 64.0f);\n    pwm_set_wrap(slice, 39062);\n    pwm_set_enabled(slice, true);\n\n    int next1 = 0;\n    int prev1 = 0;\n\n    // Botones con pull-up interna\n    gpio_init(btn_mode);\n    gpio_set_dir(btn_mode, GPIO_IN);\n    gpio_pull_up(btn_mode);\n\n    gpio_init(btn_next);\n    gpio_set_dir(btn_next, GPIO_IN);\n    gpio_pull_up(btn_next);\n\n    gpio_init(btn_prev);\n    gpio_set_dir(btn_prev, GPIO_IN);\n    gpio_pull_up(btn_prev);\n\n    // Interrupci\u00f3n bot\u00f3n modo\n    gpio_set_irq_enabled_with_callback(btn_mode, GPIO_IRQ_EDGE_FALL, true, &amp;button_isr);\n\n    string p1 = \"\";\n    int lista[list] = {720, 720, 720, 720, 720, 720, 720, 720, 720, 720};\n    int i = -1;\n\n    while (true) {\n        int pos = 0;\n\n        if (programa == 0) {\n            int ch = getchar_timeout_us(0);\n            if (ch != PICO_ERROR_TIMEOUT) {\n\n                if (ch == ',') {\n                    if (p1 == \"Escribir\" || p1 == \"write\" || p1 == \"WRITE\" || p1 == \"escribir\" || p1 == \"Write\" || p1 == \"ESCRIBIR\") {\n                        p1 = \"\";\n                        int contador = 0;\n                        for (int k = 0; k &lt; list; k++) {\n                            if (lista[k] != 720) {\n                                contador++;\n                            }\n                        }\n                        if (contador == list) {\n                            printf(\"Lista llena, no se pueden agregar mas elementos.\\n\");\n                            p1 = \"\";\n                            continue;\n                        } else {\n                            i++;\n                            while (ch != ';' &amp;&amp; ch != '\\n') {\n                                ch = getchar_timeout_us(0);\n                                if (ch != PICO_ERROR_TIMEOUT) {\n                                    if (ch == ',') {\n                                        printf(\"Eco: %s\\n\", p1.c_str());\n                                        if (stoi(p1) &gt; 180 || stoi(p1) &lt; 0) {\n                                            printf(\"Valor fuera de rango (0-180). Intente de nuevo.\\n\");\n                                            i--;\n                                        } else {\n                                            lista[i] = stoi(p1);\n                                            i++;\n                                            p1 = \"\";\n                                        }\n                                    } else if (ch == ';' || ch == '\\n') {\n                                        if (stoi(p1) &gt; 180 || stoi(p1) &lt; 0) {\n                                            printf(\"Valor fuera de rango (0-180). Intente de nuevo.\\n\");\n                                            i--;\n                                        } else {\n                                            lista[i] = stoi(p1);\n                                            p1 = \"\";\n                                        }\n                                    } else {\n                                        p1 += (char)ch;\n                                    }\n\n                                    printf(\"Lista: \");\n                                    for (int k = 0; k &lt;= i; ++k) {\n                                        printf(\"%d\", lista[k]);\n                                        if (k + 1 &lt;= i) printf(\", \");\n                                    }\n                                    printf(\"\\n\");\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (ch == ';' || ch == '\\n') {\n                    if (p1 == \"Borrar\" || p1 == \"delete\" || p1 == \"DELETE\" || p1 == \"borrar\" || p1 == \"BORRAR\") {\n                        for (int k = 0; k &lt; list; k++) lista[k] = 720;\n                        i = -1;\n                        printf(\"Ok, Lista borrada\\n\");\n                    }\n                    p1 = \"\";\n                } else {\n                    p1 += (char)ch;\n                }\n            }\n        } else if (programa == 1) {\n            while (programa == 1) {\n                int contador = 0;\n                for (int k = 0; k &lt; list; k++) {\n                    if (lista[k] != 720) contador++;\n                }\n                if (contador == 0) {\n                    printf(\"La lista esta vacia. Cambie al modo de escritura.\\n\");\n                    sleep_ms(1500);\n                } else {\n                    int j = 0;\n                    while (programa == 1 &amp;&amp; j &lt; contador) {\n                        printf(\"posicion: %d , valor: %d\\n\", j, lista[j]);\n                        pwm_set_gpio_level(SERVO_PIN, angle_to_pwm(lista[j]));\n                        printf(\"Angulo: %.1f\u00b0\\n\", lista[j]);\n                        sleep_ms(1500);\n                        j++;\n                    }\n                }\n            }\n        } else if (programa == 2) {\n            while (programa == 2) {\n                static int i = 0;\n                const int LISTA_LEN = 10;\n\n                if (lista[pos] == 720) pos--;\n                int contador = 0;\n                for (int k = 0; k &lt; list; k++) if (lista[k] != 720) contador++;\n\n                if (next1 == 0 &amp;&amp; gpio_get(btn_next) == 1) {\n                    if (contador == 0 &amp;&amp; gpio_get(btn_next) == 1) {\n                        printf(\"Lista Vacia, no se puede avanzar.\\n\");\n                        sleep_ms(100);\n                    } else {\n                        pos++;\n                        printf(\"siguiente \\n\");\n                        if (lista[pos] == 720) {\n                            printf(\"Valor no valido, regresando a %d\\n\", pos - 1);\n                            pos--;\n                        }\n                        if (pos == list) pos = 0;\n                        printf(\"posicion: %d , valor: %d\\n\", pos, lista[pos]);\n                        pwm_set_gpio_level(SERVO_PIN, angle_to_pwm(lista[pos]));\n                        printf(\"Angulo: %.1f\u00b0\\n\", lista[pos]);\n                        sleep_ms(200);\n                    }\n                }\n                next1 = gpio_get(btn_next);\n\n                if (prev1 == 0 &amp;&amp; gpio_get(btn_prev) == 1) {\n                    if (contador == 0 &amp;&amp; gpio_get(btn_prev) == 1) {\n                        printf(\"Lista Vacia, no se puede avanzar.\\n\");\n                        sleep_ms(100);\n                    } else {\n                        pos--;\n                        printf(\"anterior \\n\");\n                        if (pos == -1) {\n                            printf(\"Valor no valido, regresando a %d\\n\", pos + 1);\n                            pos++;\n                        }\n                        if (pos == list) pos = 0;\n                        printf(\"posicion: %d , valor: %d\\n\", pos, lista[pos]);\n                        pwm_set_gpio_level(SERVO_PIN, angle_to_pwm(lista[pos]));\n                        printf(\"Angulo: %.1f\u00b0\\n\", lista[pos]);\n                        sleep_ms(200);\n                    }\n                }\n                prev1 = gpio_get(btn_prev);\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Examen2/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"Examen2/#a-pwm-control-del-servo","title":"a) PWM (Control del Servo)","text":"<ul> <li>La frecuencia del PWM se configura aproximadamente a 50 Hz, ideal para servos convencionales.  </li> <li>Los par\u00e1metros clave son:</li> <li><code>clkdiv = 64</code> </li> <li><code>wrap = 39062</code>   Estos valores generan un periodo de 20 ms.  </li> <li>La funci\u00f3n <code>angle_to_pwm(angle)</code> convierte un \u00e1ngulo de 0 a 180\u00b0 en una se\u00f1al de 1.0 a 2.0 ms, correspondiente al rango completo del servo.  </li> <li>El c\u00e1lculo interno es:   [   \\text{ticks} = \\frac{\\text{pulso_ms}}{20\\text{ ms}} \\times 39062   ]   obteniendo valores entre 1953 (0\u00b0) y 3906 (180\u00b0).</li> </ul>"},{"location":"Examen2/#b-modos-de-operacion","title":"b) Modos de operaci\u00f3n","text":"<p>El sistema utiliza tres modos definidos por la variable global <code>programa</code>, la cual cambia mediante interrupci\u00f3n con el bot\u00f3n <code>btn_mode</code> (GPIO 16):</p> Modo Valor Descripci\u00f3n Modo 0 \u2013 Escritura 0 Permite cargar una lista de \u00e1ngulos desde la consola UART. Modo 1 \u2013 Lectura 1 Reproduce autom\u00e1ticamente la lista de \u00e1ngulos almacenados. Modo 2 \u2013 Navegaci\u00f3n 2 Permite avanzar o retroceder por la lista usando los botones f\u00edsicos. <p>Cada modo imprime en consola su nombre al activarse:</p> <ul> <li> <p>Modo de Escritura Activado</p> </li> <li> <p>Modo de Lectura Activado</p> </li> <li> <p>Modo de Navegacion Activado</p> </li> </ul>"},{"location":"Examen2/#c-logica-de-los-modos","title":"c) L\u00f3gica de los modos","text":""},{"location":"Examen2/#modo-0-escritura","title":"\ud83d\udd39 Modo 0 \u2013 Escritura","text":"<ul> <li>Usa <code>getchar_timeout_us(0)</code> para leer texto de la consola.  </li> <li>Admite los siguientes comandos:</li> </ul> Comando Funci\u00f3n <code>Escribir,90,120,45,0,180;</code> Carga una lista con los \u00e1ngulos proporcionados. <code>Borrar;</code> Vac\u00eda completamente la lista. <ul> <li>Los valores deben estar entre 0 y 180 grados.  </li> <li>Se almacenan en un arreglo <code>lista[10]</code> con un m\u00e1ximo de 10 posiciones.  </li> <li>El valor 720 indica posici\u00f3n vac\u00eda.  </li> <li>Cada vez que se agrega un valor, el sistema imprime la lista actualizada</li> </ul>"},{"location":"Examen2/#d-interrupcion-de-cambio-de-modo","title":"d) Interrupci\u00f3n de cambio de modo","text":"<ul> <li>El bot\u00f3n de modo (GPIO 16) est\u00e1 configurado con pull-up interno.  </li> <li>Se detecta un flanco de bajada (cuando el bot\u00f3n se presiona a GND).  </li> <li>La interrupci\u00f3n ejecuta <code>button_isr()</code>, que incrementa <code>programa</code> (0 \u2192 1 \u2192 2 \u2192 0).  </li> <li>Se incluye un <code>sleep_ms(500)</code> dentro de la ISR para evitar rebotes, aunque se recomienda migrarlo al bucle principal.</li> </ul>"},{"location":"Examen2/#e-comunicacion-uart-consola","title":"e) Comunicaci\u00f3n UART / Consola","text":"<ul> <li>Configurada a 115200 bps, 8 bits de datos, sin paridad, 1 bit de parada (8N1).  </li> <li>El c\u00f3digo inicializa UART0 (GPIO 0/1), pero el <code>stdio</code> est\u00e1 disponible por USB CDC, por lo que se puede usar directamente el Monitor Serial del entorno de desarrollo sin cablear TX/RX.  </li> <li>Si se desea usar UART f\u00edsico, conectar TX (GP0) y RX (GP1) con GND com\u00fan.</li> </ul>"},{"location":"Examen2/#6-video-de-demostracion","title":"6) Video de demostracion","text":""},{"location":"Inputs/","title":"Practica 2: Inputs","text":""},{"location":"Inputs/#1-resumen","title":"1) Resumen","text":"<p>Nombre del proyecto: Pr\u00e1cticas de Compuertas L\u00f3gicas y Secuencias con Raspberry Pi Pico 2</p> <p>Equipo / Autor(es): Rodrigo Zarate Fernandez</p> <p>Curso / Asignatura: Sistemas Embebidos / Microcontroladores</p> <p>Fecha: 1/09/2025</p> <p>Descripci\u00f3n breve: Conjunto de programas que utilizan la Raspberry Pi Pico 2 para manejar entradas digitales (botones) y salidas (LEDs), implementando:</p> <p>Visualizaci\u00f3n de las compuertas b\u00e1sicas AND, OR y XOR con dos botones como entradas.</p> <p>Un selector c\u00edclico de 4 LEDs controlado con botones de avance y retroceso, con l\u00f3gica de antirrebote por flanco.</p>"},{"location":"Inputs/#2-objetivos","title":"2) Objetivos","text":"<p>General:</p> <p>Aprender el manejo de entradas digitales con resistencias pull-up internas y el uso de l\u00f3gica booleana en MicroPython para controlar m\u00faltiples LEDs.</p> <p>Espec\u00edficos:</p> <p>Implementar compuertas l\u00f3gicas b\u00e1sicas (AND, OR, XOR) con dos botones como entradas.</p> <p>Mostrar el resultado de las tres operaciones en paralelo con LEDs.</p> <p>Programar un selector c\u00edclico de LEDs con botones de avance y retroceso.</p> <p>Incluir l\u00f3gica de antirrebote por flanco en botones.</p>"},{"location":"Inputs/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<p>Incluye:</p> <p>C\u00f3digo en MicroPython para ambos ejercicios.</p> <p>Esquem\u00e1tico b\u00e1sico de conexiones (botones y LEDs).</p> <p>Documentaci\u00f3n en Markdown para p\u00e1gina o repositorio.</p> <p>No incluye:</p> <p>Implementaci\u00f3n de compuertas con hardware discreto (solo emulaci\u00f3n por software).</p> <p>Variantes en C/C++.</p> <p>Dise\u00f1o de PCB o simulaci\u00f3n.</p>"},{"location":"Inputs/#4-requisitos","title":"4) Requisitos","text":"<p>Software:</p> <p>Thonny IDE o uPyCraft.</p> <p>Firmware MicroPython en Raspberry Pi Pico 2.</p> <p>Hardware Componente| Cant.   |Nota Raspberry Pi Pico 2 |1  |MCU principal LED rojo    |7  |3 para compuertas, 4 para selector Resistencias 1 k\u03a9   |7  |Limitadoras de corriente Botones pulsadores  |4| A, B, Avanza, Retrocede Protoboard  |1| Conexi\u00f3n r\u00e1pida Cables Dupont   |Varios|    Macho\u2013macho</p> <p>Conocimientos previos:</p> <p>Operaciones l\u00f3gicas (AND, OR, XOR).</p> <p>Manejo de interrupciones o lectura por polling de botones.</p> <p>Antirrebote por software (detecci\u00f3n de flanco).</p> <p>Programaci\u00f3n b\u00e1sica en MicroPython.</p>"},{"location":"Inputs/#5-desarrollo","title":"5) Desarrollo","text":""},{"location":"Inputs/#51-compuertas-basicas-and-or-xor-con-2-botones","title":"5.1 Compuertas b\u00e1sicas AND / OR / XOR con 2 botones","text":"<p>Entradas: Botones A y B, configurados con pull-up (reposo=1, presionado=0).</p> <p>Salidas: Tres LEDs que muestran en tiempo real el resultado de las operaciones:</p> <p>LED1 = A AND B</p> <p>LED2 = A OR B</p> <p>LED3 = A XOR B</p> <p>Demostraci\u00f3n en video: Se deben probar las 4 combinaciones de entradas: (00, 01, 10, 11).</p>"},{"location":"Inputs/#esquematico","title":"Esquematico","text":""},{"location":"Inputs/#codigo","title":"Codigo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/timer.h\"\n#include \"hardware/gpio.h\"\n\n// Pines de LEDs de la cancha\n#define LED0 9\n#define LED1 10\n#define LED2 11\n#define LED3 12\n#define LED4 13\n\n// LEDs de puntuaci\u00f3n\n#define LED_SCORE_P1 7\n#define LED_SCORE_P2 8\n\n// Botones\n#define BTN_P1 14\n#define BTN_P2 15\n\n// Variables del juego\nvolatile int pelota_pos = 2;       // posici\u00f3n inicial (LED del centro)\nvolatile int direccion = 1;        // 1 \u2192 derecha, -1 \u2192 izquierda\nvolatile bool esperando_respuesta = false;\n\n// Prototipos\nbool mover_pelota(struct repeating_timer *t);\nvoid actualizar_leds();\nvoid btn_callback(uint gpio, uint32_t events);\n\nint main() {\n    stdio_init_all();\n\n    // Configuraci\u00f3n LEDs\n    int leds[] = {LED0, LED1, LED2, LED3, LED4, LED_SCORE_P1, LED_SCORE_P2};\n    for (int i = 0; i &lt; 7; i++) {\n        gpio_init(leds[i]);\n        gpio_set_dir(leds[i], true);\n        gpio_put(leds[i], 0);\n    }\n\n    // Configuraci\u00f3n botones\n    // Configuraci\u00f3n bot\u00f3n jugador 1\ngpio_init(BTN_P1);\ngpio_set_dir(BTN_P1, false);\ngpio_pull_up(BTN_P1);\n\n// Configuraci\u00f3n bot\u00f3n jugador 2\ngpio_init(BTN_P2);\ngpio_set_dir(BTN_P2, false);\ngpio_pull_up(BTN_P2);\n\n// Registrar el callback global UNA sola vez\ngpio_set_irq_enabled_with_callback(BTN_P1, 0x8u, true, &amp;btn_callback);\n\n// Habilitar interrupci\u00f3n tambi\u00e9n en el otro bot\u00f3n, sin registrar callback otra vez\ngpio_set_irq_enabled(BTN_P2, 0x8u, true);\n\n\n    // Timer para mover la pelota\n    struct repeating_timer timer;\n    add_repeating_timer_ms(500, mover_pelota, NULL, &amp;timer);\n\n    while (true) {\n        tight_loop_contents(); // loop vac\u00edo, todo se maneja con interrupciones y timer\n    }\n}\n\n// Timer: mueve la pelota\nbool mover_pelota(struct repeating_timer *t) {\n    if (esperando_respuesta) return true; // espera al jugador\n\n    // Apagar LEDs\n    for (int i = LED0; i &lt;= LED4; i++) gpio_put(i, 0);\n\n    // Mover pelota\n    pelota_pos += direccion;\n\n    // Revisar si lleg\u00f3 al extremo\n    if (pelota_pos &lt;= 0) {\n        esperando_respuesta = true; // espera bot\u00f3n del jugador 1\n        pelota_pos = 0;\n    } else if (pelota_pos &gt;= 4) {\n        esperando_respuesta = true; // espera bot\u00f3n del jugador 2\n        pelota_pos = 4;\n    }\n\n    actualizar_leds();\n    return true;\n}\n\n// Encender LED de la pelota\nvoid actualizar_leds() {\n    gpio_put(LED0, pelota_pos == 0);\n    gpio_put(LED1, pelota_pos == 1);\n    gpio_put(LED2, pelota_pos == 2);\n    gpio_put(LED3, pelota_pos == 3);\n    gpio_put(LED4, pelota_pos == 4);\n}\n\n// Callback de botones (interrupciones)\nvoid btn_callback(uint gpio, uint32_t events) {\n    if (!esperando_respuesta) return;\n\n    if (gpio == BTN_P1 &amp;&amp; pelota_pos == 0) {\n        direccion = 1; // devuelve hacia la derecha\n        esperando_respuesta = false;\n    } \n    else if (gpio == BTN_P2 &amp;&amp; pelota_pos == 4) {\n        direccion = -1; // devuelve hacia la izquierda\n        esperando_respuesta = false;\n    } \n    else {\n        // Fall\u00f3 \u2192 punto para el contrario\n        if (gpio == BTN_P1) {\n            gpio_put(LED_SCORE_P2, 1);\n            sleep_ms(500);\n            gpio_put(LED_SCORE_P2, 0);\n        } else {\n            gpio_put(LED_SCORE_P1, 1);\n            sleep_ms(500);\n            gpio_put(LED_SCORE_P1, 0);\n        }\n        // Reiniciar pelota\n        pelota_pos = 2;\n        direccion = (gpio == BTN_P1) ? 1 : -1;\n        esperando_respuesta = false;\n    }\n    actualizar_leds();\n}\n</code></pre>"},{"location":"Inputs/#video","title":"Video","text":"<p>Video Compuertas AND / OR / XOR</p>"},{"location":"Inputs/#52-selector-ciclico-de-4-leds-con-avanceretroceso","title":"5.2 Selector c\u00edclico de 4 LEDs con avance/retroceso","text":"<p>Entradas:</p> <p>Bot\u00f3n AVANZA \u2192 incrementa el \u00edndice (0 \u2192 1 \u2192 2 \u2192 3 \u2192 0).</p> <p>Bot\u00f3n RETROCEDE \u2192 decrementa el \u00edndice (0 \u2192 3 \u2192 2 \u2192 1 \u2192 0).</p> <p>Salida: Solo un LED encendido a la vez entre LED0..LED3.</p> <p>Condici\u00f3n: Cada pulsaci\u00f3n cuenta solo una vez (antirrebote por flanco). Mantener presionado no genera m\u00faltiples avances.</p> <p>Demostraci\u00f3n en video: Se recorre en ambos sentidos mostrando el funcionamiento correcto.</p>"},{"location":"Inputs/#esquematico_1","title":"Esquematico","text":""},{"location":"Inputs/#codigo_1","title":"Codigo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/timer.h\"\n#include \"hardware/gpio.h\"\n\n// Pines de LEDs de la cancha\n#define LED0 9\n#define LED1 10\n#define LED2 11\n#define LED3 12\n#define LED4 13\n\n// LEDs de puntuaci\u00f3n\n#define LED_SCORE_P1 7\n#define LED_SCORE_P2 8\n\n// Botones\n#define BTN_P1 14\n#define BTN_P2 15\n\n// Variables del juego\nvolatile int pelota_pos = 2;       // posici\u00f3n inicial (LED del centro)\nvolatile int direccion = 1;        // 1 \u2192 derecha, -1 \u2192 izquierda\nvolatile bool esperando_respuesta = false;\n\n// Prototipos\nbool mover_pelota(struct repeating_timer *t);\nvoid actualizar_leds();\nvoid btn_callback(uint gpio, uint32_t events);\n\nint main() {\n    stdio_init_all();\n\n    // Configuraci\u00f3n LEDs\n    int leds[] = {LED0, LED1, LED2, LED3, LED4, LED_SCORE_P1, LED_SCORE_P2};\n    for (int i = 0; i &lt; 7; i++) {\n        gpio_init(leds[i]);\n        gpio_set_dir(leds[i], true);\n        gpio_put(leds[i], 0);\n    }\n\n    // Configuraci\u00f3n botones\n    // Configuraci\u00f3n bot\u00f3n jugador 1\ngpio_init(BTN_P1);\ngpio_set_dir(BTN_P1, false);\ngpio_pull_up(BTN_P1);\n\n// Configuraci\u00f3n bot\u00f3n jugador 2\ngpio_init(BTN_P2);\ngpio_set_dir(BTN_P2, false);\ngpio_pull_up(BTN_P2);\n\n// Registrar el callback global UNA sola vez\ngpio_set_irq_enabled_with_callback(BTN_P1, 0x8u, true, &amp;btn_callback);\n\n// Habilitar interrupci\u00f3n tambi\u00e9n en el otro bot\u00f3n, sin registrar callback otra vez\ngpio_set_irq_enabled(BTN_P2, 0x8u, true);\n\n\n    // Timer para mover la pelota\n    struct repeating_timer timer;\n    add_repeating_timer_ms(500, mover_pelota, NULL, &amp;timer);\n\n    while (true) {\n        tight_loop_contents(); // loop vac\u00edo, todo se maneja con interrupciones y timer\n    }\n}\n\n// Timer: mueve la pelota\nbool mover_pelota(struct repeating_timer *t) {\n    if (esperando_respuesta) return true; // espera al jugador\n\n    // Apagar LEDs\n    for (int i = LED0; i &lt;= LED4; i++) gpio_put(i, 0);\n\n    // Mover pelota\n    pelota_pos += direccion;\n\n    // Revisar si lleg\u00f3 al extremo\n    if (pelota_pos &lt;= 0) {\n        esperando_respuesta = true; // espera bot\u00f3n del jugador 1\n        pelota_pos = 0;\n    } else if (pelota_pos &gt;= 4) {\n        esperando_respuesta = true; // espera bot\u00f3n del jugador 2\n        pelota_pos = 4;\n    }\n\n    actualizar_leds();\n    return true;\n}\n\n// Encender LED de la pelota\nvoid actualizar_leds() {\n    gpio_put(LED0, pelota_pos == 0);\n    gpio_put(LED1, pelota_pos == 1);\n    gpio_put(LED2, pelota_pos == 2);\n    gpio_put(LED3, pelota_pos == 3);\n    gpio_put(LED4, pelota_pos == 4);\n}\n\n// Callback de botones (interrupciones)\nvoid btn_callback(uint gpio, uint32_t events) {\n    if (!esperando_respuesta) return;\n\n    if (gpio == BTN_P1 &amp;&amp; pelota_pos == 0) {\n        direccion = 1; // devuelve hacia la derecha\n        esperando_respuesta = false;\n    } \n    else if (gpio == BTN_P2 &amp;&amp; pelota_pos == 4) {\n        direccion = -1; // devuelve hacia la izquierda\n        esperando_respuesta = false;\n    } \n    else {\n        // Fall\u00f3 \u2192 punto para el contrario\n        if (gpio == BTN_P1) {\n            gpio_put(LED_SCORE_P2, 1);\n            sleep_ms(500);\n            gpio_put(LED_SCORE_P2, 0);\n        } else {\n            gpio_put(LED_SCORE_P1, 1);\n            sleep_ms(500);\n            gpio_put(LED_SCORE_P1, 0);\n        }\n        // Reiniciar pelota\n        pelota_pos = 2;\n        direccion = (gpio == BTN_P1) ? 1 : -1;\n        esperando_respuesta = false;\n    }\n    actualizar_leds();\n}\n</code></pre>"},{"location":"Inputs/#video_1","title":"Video","text":"<p>Video Selector Ciclico</p>"},{"location":"Pong/","title":"Pong","text":""},{"location":"Pong/#1-resumen","title":"1) Resumen","text":"<p>Nombre del proyecto: Pong de LEDs con interrupciones</p> <p>Equipo / Autor(es): Rodrigo Zarate Fernandez</p> <p>Curso / Asignatura: Sistemas Embebidos</p> <p>Fecha: 01/09/2025</p> <p>Descripci\u00f3n breve: Juego de \u201cPong\u201d unidimensional usando 5 LEDs para la pelota, 2 salidas para puntos y 2  botones con interrupciones para devolver la pelota en los extremos. Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (pico/stdlib.h). T\u00e9cnicas clave: manejo de GPIO, interrupciones por flanco de bajada, pull-ups internos, l\u00f3gica de estados. Plataforma: Raspberry Pi Pico / Pico 2.</p> <p>Material utilizado:</p> <p>Raspberry Pi Pico (o Pico 2) + cable micro-USB/USB-C</p> <p>Protoboard</p> <p>7 LEDs (5 para \u201ccancha\u201d, 2 para puntos J1/J2)</p> <p>7 resistencias 220\u2013330 \u03a9 (una por LED)</p> <p>2 botones moment\u00e1neos</p> <p>2 resistencias 1K-2K \u03a9 para los botones</p> <p>Cables de conexi\u00f3n (jumpers)</p> <p>PC con VS Code + Pico SDK configurado</p>"},{"location":"Pong/#2-objetivos","title":"2) Objetivos","text":"<p>Usar interrupciones GPIO para leer botones con pull-up interno (activo en bajo). Modelar la l\u00f3gica de juego con variables de posici\u00f3n (pos) y direcci\u00f3n (dir). Indicar estado del juego en hardware: 5 LEDs para pelota, 2 salidas para \u201cpunto\u201d. Practicar estructura de programa embebido (inicializaci\u00f3n\u2013ISR\u2013bucle principal).</p>"},{"location":"Pong/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>Botones (activos en bajo): - Un terminal del bot\u00f3n a GND; el otro a GPIO 14 (BTN_AVANZA) y GPIO 15 (BTN_RETRO). Se habilita gpio_pull_up(), por lo que al presionar el bot\u00f3n, la l\u00ednea cae a 0 (flanco de bajada).</p> <p>LEDs \u201ccancha\u201d (con resistencia a GND):</p> <ul> <li> <p>LED4 \u2192 GPIO 9</p> </li> <li> <p>LED0 \u2192 GPIO 10</p> </li> <li> <p>LED1 \u2192 GPIO 11</p> </li> <li> <p>LED2 \u2192 GPIO 12</p> </li> <li> <p>LED3 \u2192 GPIO 13</p> </li> </ul> <p>LEDs de \u201cpunto\u201d (o zumbadores, seg\u00fan el montaje):</p> <ul> <li> <p>J1 \u2192 GPIO 7 (punto del jugador izquierdo)</p> </li> <li> <p>J2 \u2192 GPIO 8 (punto del jugador derecho)</p> </li> </ul> <p>Recomendaci\u00f3n: conectar \u00e1nodo del LED a GPIO mediante resistencia serie y c\u00e1todo a GND. Con gpio_put(pin, 1) el LED enciende.</p> <p>Tabla r\u00e1pida de pines</p> Se\u00f1al GPIO Uso BTN_AVANZA 14 Bot\u00f3n jugador izquierdo BTN_RETRO 15 Bot\u00f3n jugador derecho LED4 9 Posici\u00f3n 1(extremo izq) LED0 10 Posici\u00f3n 2 LED1 11 Posici\u00f3n 3 (centro) LED2 12 Posici\u00f3n 4 LED3 13 Posici\u00f3n 5(extremo der) J1 7 Indicador de punto izq J2 8 Indicador de punto der"},{"location":"Pong/#esquematico","title":"Esquematico","text":""},{"location":"Pong/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdbool.h&gt;\n\n#define BTN_AVANZA 14\n#define BTN_RETRO  15\n\n#define LED4 9\n#define LED0 10\n#define LED1 11\n#define LED2 12\n#define LED3 13\n#define J1 7\n#define J2 8\n\nbool Ju1 = false;   // estado bot\u00f3n jugador 1\nbool Ju2 = false;   // estado bot\u00f3n jugador 2\nint pos = 1;        // posici\u00f3n inicial de la pelota\nint dir = 1;        // direcci\u00f3n inicial: 1=derecha, -1=izquierda\n\nstatic void accion(uint gpio, uint32_t events) {\n    // FIX: habilitaste FALL en main; aqu\u00ed tambi\u00e9n revisa FALL y atiende ambos botones\n    if (events &amp; GPIO_IRQ_EDGE_FALL) {\n        if (gpio == BTN_AVANZA) { if (pos == 1 /*&amp;&amp; Ju1*/) dir = 1; }  // Ju1 opcional\n        if (gpio == BTN_RETRO)  { if (pos == 5 /*&amp;&amp; Ju2*/) dir = -1; } // Ju2 opcional\n    }\n    gpio_acknowledge_irq(gpio, events);\n}\n\nint main() {\n    stdio_init_all();\n\n    const uint LEDS[5] = { LED4, LED0, LED1, LED2, LED3 };  // 9,10,11,12,13\n\n    for (int i = 0; i &lt; 5; i++) {                  // FIX: antes era &lt; 4\n        gpio_init(LEDS[i] );\n        gpio_set_dir(LEDS[i], true);\n        gpio_put(LEDS[i], 0);                      // FIX: apaga inicialmente\n    }\n\n    const uint PUNTOS[2] = { J1, J2 };\n    for (int i = 0; i &lt; 2; i++) {\n        gpio_init(PUNTOS[i] );                      // FIX: inicializa PUNTOS, no LEDS\n        gpio_set_dir(PUNTOS[i], true);              // FIX: salida\n        gpio_put(PUNTOS[i], 0);                     // FIX: apaga inicialmente\n    }\n\n    // Botones como entrada con pull-up (activo en bajo)\n    gpio_init(BTN_AVANZA); gpio_set_dir(BTN_AVANZA, false); gpio_pull_up(BTN_AVANZA);\n    gpio_init(BTN_RETRO);  gpio_set_dir(BTN_RETRO,  false); gpio_pull_up(BTN_RETRO);\n\n    // IRQ: instalas callback con el primero y habilitas tambi\u00e9n el segundo\n    gpio_set_irq_enabled_with_callback(BTN_AVANZA, GPIO_IRQ_EDGE_FALL, true, &amp;accion);\n    gpio_set_irq_enabled(BTN_RETRO,  GPIO_IRQ_EDGE_FALL, true);\n\n    while (true) {\n        // (Opcional) actualizar flags de botones si los quieres usar en otro lado\n        Ju1 = !gpio_get(BTN_AVANZA);\n        Ju2 = !gpio_get(BTN_RETRO);\n\n        // --- Movimiento autom\u00e1tico ---\n        pos += dir;\n\n        // Rebotes en bordes si nadie responde\n        if (pos == 6) {\n            for (int i = 0; i &lt; 5; i++) gpio_put(LEDS[i], 1);\n            gpio_put(J2, 1);\n            sleep_ms(2000);\n            gpio_put(J2, 0);\n            pos = 3;\n            // (tu l\u00f3gica original no reubica pos ni dir aqu\u00ed m\u00e1s all\u00e1 del if)\n        }\n\n        if (pos == 0) {\n            for (int i = 0; i &lt; 5; i++) gpio_put(LEDS[i], 1);\n            gpio_put(J1, 1);\n            sleep_ms(2000);\n            gpio_put(J1, 0);\n            pos = 3;\n        }\n\n        // --- Mostrar LEDs ---\n        for (int i = 0; i &lt; 5; i++) {\n            gpio_put(LEDS[i], (i + 1 == pos));     // LEDS[0] \u2194 pos=1 ... LEDS[4] \u2194 pos=5\n        }\n\n        sleep_ms(250);\n    }\n}\n</code></pre>"},{"location":"Pong/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":"<p>a) Definiciones y mapeo de pines Botones: BTN_AVANZA=14, BTN_RETRO=15 (entradas con pull-up, activos en bajo). LEDs \u201ccancha\u201d: LED4=9, LED0=10, LED1=11, LED2=12, LED3=13. Se agrupan en LEDS[5] = { LED4, LED0, LED1, LED2, LED3 }, donde pos=1 corresponde a LEDS[0] (GPIO 9) y pos=5 a LEDS[4] (GPIO 13). Indicadores de punto: J1=7 (izquierda), J2=8 (derecha). Se configuran como salidas y se encienden 2 s al anotar.</p> <p>b) Variables de estado pos \u2208 {1,2,3,4,5} indica la posici\u00f3n de la pelota. dir \u2208 {+1, \u22121} define la direcci\u00f3n (derecha/izquierda). Ju1, Ju2 sirven como flags de lectura (opcionales, el juego funciona sin usarlas).</p> <p>c) Interrupci\u00f3n accion() Se activa con flanco de bajada (GPIO_IRQ_EDGE_FALL) en cualquiera de los dos botones. L\u00f3gica de \u201cdevoluci\u00f3n\u201d: Si la pelota est\u00e1 en el extremo izquierdo (pos==1) y cae el bot\u00f3n izquierdo (BTN_AVANZA), se fuerza dir = +1. Si est\u00e1 en el extremo derecho (pos==5) y cae el bot\u00f3n derecho (BTN_RETRO), se fuerza dir = \u22121. Se llama a gpio_acknowledge_irq() para limpiar el evento atendido.</p> <p>d) Inicializaci\u00f3n en main() LEDS y PUNTOS se inicializan como salidas y se apagan. Botones se configuran como entradas con gpio_pull_up(). Se registra la ISR con gpio_set_irq_enabled_with_callback() en BTN_AVANZA y se habilita tambi\u00e9n la IRQ de BTN_RETRO.</p> <p>e) Bucle principal (Opcional) Actualiza Ju1/Ju2 leyendo el estado instant\u00e1neo de los botones. Movimiento: pos += dir; Punto/anotaci\u00f3n si la pelota \u201csale\u201d: Derecha: si pos==6, se encienden todos los LEDs de cancha, se activa J2 por 2 s y se reinicia pos=3. Izquierda: si pos==0, se encienden todos los LEDs de cancha, se activa J1 por 2 s y se reinicia pos=3. (La direcci\u00f3n dir no se reorienta expl\u00edcitamente tras el punto.) Render: se enciende \u00fanicamente el LED cuyo \u00edndice+1 == pos. Velocidad: sleep_ms(250) define la dificultad.</p>"},{"location":"Pong/#6-pruebas-y-comportamiento-esperado","title":"6) Pruebas y comportamiento esperado","text":"<p>Arranque: un \u00fanico LED encendido en la posici\u00f3n 1; la \u201cpelota\u201d avanza hacia la derecha (dir=+1). Devoluci\u00f3n correcta: al llegar al LED extremo, si el jugador correspondiente presiona a tiempo, la pelota cambia de sentido sin salir. Fallo: si nadie presiona y la pelota intenta pasar de 5\u21926 o 1\u21920, se marca punto (J2 o J1, respectivamente) y se reinicia en el centro (pos=3).</p>"},{"location":"Pong/#video","title":"Video","text":"<p>Video Pong</p>"},{"location":"Practica1_Outputs_basicos/","title":"Practica 1: Outputs Basicos","text":""},{"location":"Practica1_Outputs_basicos/#1-resumen","title":"1) Resumen","text":"<p>Nombre del proyecto: Pr\u00e1cticas de LEDs con Raspberry Pi Pico 2</p> <p>Equipo / Autor(es): Rodrigo Zarate Fernandez</p> <p>Curso / Asignatura: Sistemas Embebidos / Microcontroladores</p> <p>Fecha: 27/08/2025</p> <p>Descripci\u00f3n breve: Conjunto de programas que utilizan la Raspberry Pi Pico 2 para controlar LEDs mediante l\u00f3gica binaria y m\u00e1scaras:</p> <p>Contador binario de 4 bits.</p> <p>Barrido de LEDs.</p> <p>Secuencia en c\u00f3digo Gray.</p>"},{"location":"Practica1_Outputs_basicos/#2-objetivos","title":"2) Objetivos","text":""},{"location":"Practica1_Outputs_basicos/#general","title":"General:","text":"<p>Aprender el manejo de GPIOs en Raspberry Pi Pico 2 y aplicar operaciones de m\u00e1scaras l\u00f3gicas para controlar m\u00faltiples LEDs.</p>"},{"location":"Practica1_Outputs_basicos/#especificos","title":"Espec\u00edficos:","text":"<p>Implementar un contador binario en LEDs.</p> <p>Realizar un barrido de un LED encendido en secuencia.</p> <p>Programar la secuencia de c\u00f3digo Gray en 4 bits.</p>"},{"location":"Practica1_Outputs_basicos/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":""},{"location":"Practica1_Outputs_basicos/#incluye","title":"Incluye:","text":"<pre><code>* C\u00f3digo en MicroPython para los tres ejercicios.\n\n* Esquem\u00e1tico b\u00e1sico de conexiones.\n\n* Documentaci\u00f3n en Markdown para integrar en p\u00e1gina o repositorio.\n</code></pre>"},{"location":"Practica1_Outputs_basicos/#no-incluye","title":"No incluye:","text":"<pre><code>* Variantes en otros lenguajes (C, C++).\n\n* Dise\u00f1o de PCB.\n\n* Ejecuci\u00f3n en simuladores (solo hardware real).\n</code></pre>"},{"location":"Practica1_Outputs_basicos/#4-requisitos","title":"4) Requisitos","text":""},{"location":"Practica1_Outputs_basicos/#software","title":"Software:","text":"<pre><code>* Thonny IDE o uPyCraft.\n\n* Firmware MicroPython en Raspberry Pi Pico 2.\n</code></pre>"},{"location":"Practica1_Outputs_basicos/#hardware","title":"Hardware","text":"<p>Componente  | Cant. | Nota Raspberry Pi Pico 2 | 1 |MCU principal LED rojo |  5   |Para los ejercicios Resistencias 1 k\u03a9|  5|  Limitadoras de corriente Protoboard  |1| Conexi\u00f3n r\u00e1pida Cables Dupont   |Varios |Macho\u2013macho</p> <p>Conocimientos previos</p> <p>Operaciones bit a bit (&amp;, |, &lt;&lt;, &gt;&gt;).</p> <p>Uso de m\u00e1scaras binarias.</p> <p>Programaci\u00f3n b\u00e1sica en MicroPython.</p>"},{"location":"Practica1_Outputs_basicos/#5-desarrollo","title":"5) Desarrollo","text":""},{"location":"Practica1_Outputs_basicos/#51-contador-binario-de-4-bits","title":"5.1  Contador binario de 4 bits","text":""},{"location":"Practica1_Outputs_basicos/#esquematico","title":"Esquematico","text":"<p> <pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#define A 12\n#define B 13    \n#define C 14\n#define D 15\n\nconst uint32_t LED_MASK = (1u &lt;&lt; A) | (1u &lt;&lt; B) | (1u &lt;&lt; C) | (1u &lt;&lt; D) ;\n\n\nint main() {\n    stdio_init_all();\n    gpio_init_mask(LED_MASK);\n    gpio_set_dir_out_masked(LED_MASK);\n    gpio_put_masked(LED_MASK, 0);\n\n    while (true) {\n\n        for (uint32_t n = 0; n &lt; 16; n++) {\n            gpio_put_masked(LED_MASK, n&lt;&lt;12);\n            sleep_ms(1000);\n        } \n       /* gpio_put_masked(LED_MASK, LED_MASK);*/\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"Practica1_Outputs_basicos/#video","title":"Video","text":""},{"location":"Practica1_Outputs_basicos/#video-contador-4-bits","title":"Video Contador 4 bits","text":""},{"location":"Practica1_Outputs_basicos/#52-barrido-leds","title":"5.2 Barrido leds","text":""},{"location":"Practica1_Outputs_basicos/#esquematico_1","title":"Esquematico","text":"<p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include \"pico/stdlib.h\"\n\n#define LED0 0\n#define LED1 1\n#define LED2 2\n#define LED3 3\n#define LED4 4\n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) | (1u &lt;&lt; LED4))\n\nint main() {\n    stdio_init_all();\n    gpio_init_mask(LED_MASK);\n    gpio_set_dir_out_masked(LED_MASK);\n\n    int pos = 0;\n    int dir = 1; // 1 = derecha, -1 = izquierda\n\n    while (true) {\n        uint32_t value = (1u &lt;&lt; pos);\n        gpio_put_masked(LED_MASK, value);\n        sleep_ms(200);\n\n        pos += dir;\n\n        if (pos == 4) dir = -1; // extremo derecho\n        if (pos == 0) dir = 1;  // extremo izquierdo\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"Practica1_Outputs_basicos/#video_1","title":"Video","text":""},{"location":"Practica1_Outputs_basicos/#video-barrido-leds","title":"Video Barrido Leds","text":""},{"location":"Practica1_Outputs_basicos/#53-secuencia-en-codigo-gray","title":"5.3 Secuencia en codigo Gray","text":""},{"location":"Practica1_Outputs_basicos/#esquematico_2","title":"Esquematico","text":"<p> <pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n\n// Pines de los LEDs\n#define LED0 2\n#define LED1 3\n#define LED2 4\n#define LED3 5\n\n// Arreglo con los LEDs\nint leds[] = {LED0, LED1, LED2, LED3};\n\n// Funci\u00f3n para convertir binario a Gray\nint bin_to_gray(int num) {\n    return num ^ (num &gt;&gt; 1);\n}\n\nint main() {\n    stdio_init_all();\n\n    // Inicializar pines como salida\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(leds[i]);\n        gpio_set_dir(leds[i], true);\n    }\n\n    while (1) {\n        // Recorrer los 16 estados (4 bits)\n        for (int i = 0; i &lt; 16; i++) {\n            int gray = bin_to_gray(i);\n\n            // Escribir cada bit en los LEDs\n            for (int b = 0; b &lt; 4; b++) {\n                int bit = (gray &gt;&gt; b) &amp; 1;\n                gpio_put(leds[b], bit);\n            }\n\n            sleep_ms(500); // Pausa entre estados\n        }\n    }\n}\n</code></pre></p>"},{"location":"Practica1_Outputs_basicos/#video_2","title":"Video","text":"<p>Video Codigo Gray</p>"},{"location":"Practicas_Raspberry_Pi_Pico_2/","title":"Practicas Raspberry Pi Pico 2","text":""},{"location":"Proyecto_Rana/","title":"Proyecto RANA","text":""},{"location":"Proyecto_Rana/#rana","title":"RANA","text":"<p>La contaminaci\u00f3n de lagos, estanques y peque\u00f1os cuerpos de agua es un problema creciente que afecta tanto al medio ambiente como a las comunidades locales. La acumulaci\u00f3n de basura pl\u00e1stica, hojas y residuos org\u00e1nicos provoca da\u00f1os en la biodiversidad, genera malos olores y dificulta el acceso al agua para fines recreativos o agr\u00edcolas.</p> <p>La limpieza manual de estos espacios resulta complicada y poco eficiente, por lo que surge la necesidad de soluciones accesibles, aut\u00f3nomas y adaptadas a estos entornos. Este proyecto propone el dise\u00f1o de un robot acu\u00e1tico de navegaci\u00f3n asistida, capaz de recolectar residuos flotantes de forma econ\u00f3mica, sustentable y escalable</p> <p>Descargar especificaci\u00f3n (PDF)</p> <p>Analis\u00eds sobre la problematica:</p> <p>Descargar especificaci\u00f3n (PDF)</p> <p>Diagrama de Gantt:</p> <p>Descargar especificaci\u00f3n (PDF)</p> <p>Marco real ganar vale la pena:</p> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"SimonDice/","title":"Simon Dice","text":""},{"location":"SimonDice/#1-resumen","title":"1) Resumen","text":"<p>Nombre del proyecto: Sim\u00f3n de LEDs con display 7 segmentos Equipo / Autor(es): Rodrigo Z\u00e1rate Curso / Asignatura: Sistemas Embebidos Fecha: 22/09/2025</p> <p>Descripci\u00f3n breve: Juego de memoria (Simon Says) que genera una secuencia aleatoria de LEDs (4 posiciones). El jugador debe repetir la secuencia usando 4 botones con pull-up interno y lectura con debounce. Un display de 7 segmentos (c\u00e1todo com\u00fan) muestra el n\u00famero de ronda, hay animaciones de inicio/fin y una animaci\u00f3n de victoria al completar todas las rondas.</p> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (pico/stdlib.h).</p> <p>T\u00e9cnicas clave: manejo de GPIO, debounce por software, generaci\u00f3n pseudoaleatoria con siembra por timestamp, l\u00f3gica de estados por rondas, control de display 7-segmentos por m\u00e1scara de bits.</p> <p>Plataforma: Raspberry Pi Pico / Pico 2.</p> <p>Material utilizado:</p> <p>Raspberry Pi Pico (o Pico 2) + cable micro-USB/USB-C</p> <p>Protoboard</p> <p>4 LEDs (juego) + 4 resistencias 220\u2013330 \u03a9 (una por LED)</p> <p>4 botones moment\u00e1neos + (opcional) 1\u20132 k\u03a9 si no se usan pull-ups internos</p> <p>Display 7 segmentos c\u00e1todo com\u00fan (1 d\u00edgito) + 8 resistencias 220\u2013330 \u03a9 (una por segmento A\u2013G y DP)</p> <p>Jumpers</p> <p>PC con VS Code + Pico SDK configurado</p>"},{"location":"SimonDice/#2-objetivos","title":"2) Objetivos","text":"<p>Leer 4 botones con pull-up interno (activos en bajo) y debounce por software.</p> <p>Generar y reproducir secuencias pseudoaleatorias de LEDs, incrementando la longitud por ronda.</p> <p>Mostrar el n\u00famero de ronda (0\u20139, A\u2013F) en un display de 7 segmentos mediante m\u00e1scaras de bits.</p> <p>Practicar estructura de firmware: inicializaci\u00f3n \u2192 lazo principal \u2192 funciones de utilidad (parpadeo, display, entrada de usuario) \u2192 animaciones de estado (win/game-over).</p>"},{"location":"SimonDice/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>GPIO asignados</p> <p>LEDs (juego, activos en alto):</p> <p>LED0 \u2192 GPIO 2</p> <p>LED1 \u2192 GPIO 3</p> <p>LED2 \u2192 GPIO 4</p> <p>LED3 \u2192 GPIO 5</p> <p>Botones (activos en bajo, con gpio_pull_up()):</p> <p>BTN0 \u2192 GPIO 6</p> <p>BTN1 \u2192 GPIO 7</p> <p>BTN2 \u2192 GPIO 8</p> <p>BTN3 \u2192 GPIO 9</p> <p>Display 7 segmentos (c\u00e1todo com\u00fan):</p> <p>Orden f\u00edsico de pines usado en el c\u00f3digo: DISPLAY_PIN = {E, D, C, Dp, G, F, A, B}</p> <p>E \u2192 GPIO 12</p> <p>D \u2192 GPIO 13</p> <p>C \u2192 GPIO 14</p> <p>Dp \u2192 GPIO 15</p> <p>G \u2192 GPIO 16</p> <p>F \u2192 GPIO 17</p> <p>A \u2192 GPIO 18</p> <p>B \u2192 GPIO 19</p> <p>Recomendaciones de conexi\u00f3n:</p> <p>LEDs: \u00e1nodo a GPIO a trav\u00e9s de resistencia serie (220\u2013330 \u03a9); c\u00e1todo a GND. gpio_put(pin, 1) enciende.</p> <p>Display c\u00e1todo com\u00fan: cada segmento (A\u2013G, DP) debe llevar su propia resistencia a la l\u00ednea del GPIO; c\u00e1todo com\u00fan del display a GND. Con esta configuraci\u00f3n, gpio_put(pin, 1) enciende el segmento.</p> <p>Botones: un terminal a GND y el otro al GPIO correspondiente; habilitar gpio_pull_up().</p> <p>Tabla r\u00e1pida de pines</p> Se\u00f1al GPIO Uso LED0 2 Bot\u00f3n jugador izquierdo LED1 3 Posici\u00f3n 3 (centro) LED2 4 Posici\u00f3n 4 LED3 5 Posici\u00f3n 5(extremo der) BTN0 6 Indicador de punto izq BTN1 7 Indicador de punto der BTN2 8 Indicador de punto izq BTN3 9 Indicador de punto der E 12 Indicador de punto izq D 13 Indicador de punto der C 14 Indicador de punto izq Dp 15 Indicador de punto der G 16 Indicador de punto izq F 17 Indicador de punto der A 18 Indicador de punto izq B 19 Indicador de punto der"},{"location":"SimonDice/#esquematico","title":"Esquematico","text":""},{"location":"SimonDice/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include &lt;pico/time.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define DIS_COUNT     8\n#define LED_COUNT     4\n#define BTN_COUNT     4\n#define MAX_STEPS     15\n\n// Pines:\nconst uint LED_PINS[LED_COUNT] = {2, 3, 4, 5};      // LEDs en GPIO 2\u20135\nconst uint BTN_PINS[BTN_COUNT] = {6, 7, 8, 9};      // Botones en GPIO 6\u20139\n// Display 7 seg c\u00e1todo com\u00fan: 12=E, 13=D, 14=C, 15=Dp, 16=G, 17=F, 18=A, 19=B\nconst uint DISPLAY_PIN[DIS_COUNT] = {12, 13, 14, 15, 16, 17, 18, 19}; // [E,D,C,Dp,G,F,A,B]\n\n// Timings (ms)\n#define LED_ON_MS       400\n#define LED_OFF_MS      150\n#define INPUT_LED_MS    200\n#define PAUSE_ROUND_MS  500\n#define DEBOUNCE_MS     25\n#define HOLD_MS         15\n\nstatic uint8_t pattern[MAX_STEPS];\nstatic uint8_t round_len = 0;\n\nstatic void led_on(uint i)  { gpio_put(LED_PINS[i], 1); }\nstatic void led_off(uint i) { gpio_put(LED_PINS[i], 0); }\n\nstatic void blink(uint i, uint on_ms) {\n    led_on(i);\n    sleep_ms(on_ms);\n    led_off(i);\n    sleep_ms(LED_OFF_MS);\n}\n\nstatic void all_off(void) {\n    for (uint i = 0; i &lt; LED_COUNT; i++) led_off(i);\n}\n\nstatic void all_blink(uint times, uint on_ms) {\n    for (uint t = 0; t &lt; times; t++) {\n        for (uint i = 0; i &lt; LED_COUNT; i++) gpio_put(LED_PINS[i], 1);\n        sleep_ms(on_ms);\n        all_off();\n        sleep_ms(LED_OFF_MS);\n    }\n}\n\n// ===== 7-SEG: utilidades =====\n// M\u00e1scara de segmentos en orden: [A,B,C,D,E,F,G,DP] (bit 0 = A, bit 7 = DP)\nstatic const uint8_t DIGIT_MASKS[16] = {\n    /*0*/ 0b00111111,\n    /*1*/ 0b00000110,\n    /*2*/ 0b01011011,\n    /*3*/ 0b01001111,\n    /*4*/ 0b01100110,\n    /*5*/ 0b01101101,\n    /*6*/ 0b01111101,\n    /*7*/ 0b00000111,\n    /*8*/ 0b01111111,\n    /*9*/ 0b01101111,\n    /*10*/ 0b01110111, // \"A\"\n    /*11*/ 0b01111100, // \"b\"\n    /*12*/ 0b00111001, // \"C\"\n    /*13*/ 0b01011110, // \"d\"  \n    /*14*/ 0b01111001, // \"E\"\n    /*15*/ 0b01110001  // \"F\"\n};\n// M\u00e1scara para \"U\" (win)\n#define SEG_U 0b00111110\n// Escribe la m\u00e1scara ABCDEFGDp en pines [E,D,C,Dp,G,F,A,B]\nstatic void seg_write_mask(uint8_t m) {\n    // C\u00e1todo com\u00fan: 1 = ON\n    gpio_put(DISPLAY_PIN[0], (m &gt;&gt; 4) &amp; 1); // E\n    gpio_put(DISPLAY_PIN[1], (m &gt;&gt; 3) &amp; 1); // D\n    gpio_put(DISPLAY_PIN[2], (m &gt;&gt; 2) &amp; 1); // C\n    gpio_put(DISPLAY_PIN[3], (m &gt;&gt; 7) &amp; 1); // Dp\n    gpio_put(DISPLAY_PIN[4], (m &gt;&gt; 6) &amp; 1); // G\n    gpio_put(DISPLAY_PIN[5], (m &gt;&gt; 5) &amp; 1); // F\n    gpio_put(DISPLAY_PIN[6], (m &gt;&gt; 0) &amp; 1); // A\n    gpio_put(DISPLAY_PIN[7], (m &gt;&gt; 1) &amp; 1); // B\n}\n\nstatic void seg_clear(void) {\n    for (int i = 0; i &lt; DIS_COUNT; i++) gpio_put(DISPLAY_PIN[i], 0);\n}\n\nstatic void seg_show_digit(int d, bool dp) {\n    if (d &lt; 0 || d &gt; 15) { seg_clear(); return; }\n    uint8_t m = DIGIT_MASKS[d];\n    seg_write_mask(m);\n}\n\nstatic void seg_show_mask(uint8_t m) { seg_write_mask(m); }\n\n// ===== Botones =====\nstatic int read_button_once(void) {\n    for (int i = 0; i &lt; BTN_COUNT; i++) {\n        if (gpio_get(BTN_PINS[i]) == 0) {      // activo en bajo (pull-up)\n            sleep_ms(DEBOUNCE_MS);\n            if (gpio_get(BTN_PINS[i]) == 0) {\n                sleep_ms(HOLD_MS);\n                while (gpio_get(BTN_PINS[i]) == 0) tight_loop_contents();\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\nstatic int wait_button_blocking(void) {\n    int b = -1;\n    while (b &lt; 0) {\n        b = read_button_once();\n        tight_loop_contents();\n    }\n    return b;\n}\n\n// ===== Aleatoriedad =====\nstatic inline uint8_t randi4(void) { return (uint8_t)(rand() &amp; 3); }\n\n// Espera a la PRIMERA pulsaci\u00f3n para iniciar y siembra RNG con su timestamp\nstatic void wait_for_start_and_seed(void) {\n    // Modo espera: display en 0, \u201ctick\u201d de LEDs hasta pulsar\n    seg_show_digit(0, false);\n    uint32_t idx = 0;\n    while (1) {\n        // mini animaci\u00f3n para que se note que est\u00e1 \u201cvivo\u201d\n        blink(idx, 80);\n        idx = (idx + 1) % LED_COUNT;\n\n        int b = read_button_once();\n        if (b &gt;= 0) {\n            // Semilla con el instante de la pulsaci\u00f3n\n            uint64_t t = time_us_64();\n            unsigned seed = (unsigned)(t ^ (t &gt;&gt; 32) ^ (b * 2654435761u));\n            srand(seed);\n            // breve pausa para no tomar esta pulsaci\u00f3n como input de juego\n            sleep_ms(200);\n            return;\n        }\n    }\n}\n\n// ===== Juego =====\nstatic void play_sequence(void) {\n    sleep_ms(PAUSE_ROUND_MS);\n    for (uint i = 0; i &lt; round_len; i++) {\n        uint8_t k = pattern[i];\n        blink(k, LED_ON_MS);\n    }\n}\n\nstatic void game_over_anim(void) {\n    for (int t = 0; t &lt; 2; t++) {\n        for (int i = 0; i &lt; LED_COUNT; i++) { blink(i, 80); }\n        for (int i = LED_COUNT - 1; i &gt;= 0; i--) { blink(i, 80); }\n    }\n    all_blink(3, 250);\n    seg_clear();\n}\n\nstatic void win_anim(void) {\n    seg_show_mask(SEG_U);\n    for (int t = 0; t &lt; 6; t++) {\n        int i = t % LED_COUNT;\n        blink(i, 120);\n    }\n    all_blink(2, 300);\n    seg_clear();\n}\n\nint main() {\n    stdio_init_all();\n\n    // Init LEDs\n    for (uint i = 0; i &lt; LED_COUNT; i++) {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], GPIO_OUT);\n        led_off(i);\n    }\n    // Init botones con pull-up\n    for (uint i = 0; i &lt; BTN_COUNT; i++) {\n        gpio_init(BTN_PINS[i]);\n        gpio_set_dir(BTN_PINS[i], GPIO_IN);\n        gpio_pull_up(BTN_PINS[i]);\n    }\n    // Init display\n    for (int i = 0; i &lt; DIS_COUNT; i++) {\n        gpio_init(DISPLAY_PIN[i]);\n        gpio_set_dir(DISPLAY_PIN[i], GPIO_OUT);\n        gpio_put(DISPLAY_PIN[i], 0);\n    }\n\n    // Se\u00f1al de encendido\n    all_blink(2, 200);\n    seg_show_digit(0, false);\n\n    while (true) {\n        // &gt;&gt;&gt; Espera a pulsaci\u00f3n para INICIAR y siembra RNG\n        wait_for_start_and_seed();\n\n        // Nueva partida\n        round_len = 0;\n        for (uint i = 0; i &lt; MAX_STEPS; i++) pattern[i] = randi4();\n\n        bool playing = true;\n        while (playing) {\n            if (round_len &lt; MAX_STEPS) round_len++;\n\n            // Mostrar ronda (mod 10)\n            seg_show_digit(round_len, false);\n\n            // Secuencia\n            play_sequence();\n\n            // Entrada del jugador\n            for (uint i = 0; i &lt; round_len; i++) {\n                int b = wait_button_blocking();\n\n                // feedback LED\n                led_on(b);\n                sleep_ms(INPUT_LED_MS);\n                led_off(b);\n\n                if ((uint8_t)b != pattern[i]) {\n                    game_over_anim();\n                    playing = false;\n                    break;\n                }\n            }\n\n            if (!playing) break;\n\n            if (round_len &gt;= MAX_STEPS) {\n                win_anim();\n                playing = false;\n                break;\n            }\n\n            // recompensa visual\n            blink(pattern[round_len - 1], 120);\n        }\n\n        // tras terminar, regresa a modo espera\n        seg_show_digit(0, false);\n        all_off();\n        // el loop vuelve a wait_for_start_and_seed()\n    }\n    return 0;\n}\n</code></pre>"},{"location":"SimonDice/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":"<p>a) Definiciones, temporizaciones y mapeos</p> <p>Constantes de tama\u00f1o: LED_COUNT = 4, BTN_COUNT = 4, DIS_COUNT = 8 (segmentos del display), MAX_STEPS = 15 (rondas m\u00e1ximas).</p> <p>Tiempos (ms): LED_ON_MS=400, LED_OFF_MS=150, INPUT_LED_MS=200, PAUSE_ROUND_MS=500, DEBOUNCE_MS=25, HOLD_MS=15. Estos controlan velocidad del juego (dificultad) y calidad de lectura de botones.</p> <p>Arreglos de pines: LED_PINS[], BTN_PINS[], DISPLAY_PIN[] con el orden f\u00edsico descrito.</p> <p>b) L\u00f3gica de display 7 segmentos</p> <p>Tabla DIGIT_MASKS[16]: define las m\u00e1scaras bit-a-bit para 0\u20139 y A\u2013F siguiendo el orden l\u00f3gico A,B,C,D,E,F,G,DP (bit 0 = A, bit 7 = DP).</p> <p>seg_write_mask(uint8_t m): realiza el mapeo de ese orden l\u00f3gico al orden f\u00edsico de pines {E,D,C,DP,G,F,A,B}.</p> <p>Ejemplo: el bit de A (bit 0) termina saliendo por DISPLAY_PIN[6] (GPIO 18).</p> <p>Como el display es c\u00e1todo com\u00fan, 1 = encendido de segmento.</p> <p>seg_show_digit(d, dp): toma d (0\u201315) y escribe la m\u00e1scara correspondiente en el display. (El par\u00e1metro dp est\u00e1 previsto, pero la m\u00e1scara de DP se controla dentro de seg_write_mask si quisieras extenderlo).</p> <p>\u00bfC\u00f3mo \u201csabe\u201d qu\u00e9 n\u00famero mostrar? Por la tabla de m\u00e1scaras (DIGIT_MASKS) donde cada n\u00famero/letra tiene definidos los segmentos que deben encenderse; luego seg_write_mask() traduce esos bits a los pines reales del display.</p> <p>c) Botones y debounce</p> <p>Activo en bajo: se habilita gpio_pull_up(), por lo que un bot\u00f3n presionado lee 0.</p> <p>read_button_once(): recorre los 4 botones, aplica debounce (DEBOUNCE_MS), fuerza un tiempo m\u00ednimo de pulsaci\u00f3n (HOLD_MS) y espera a la liberaci\u00f3n (evita repeticiones). Devuelve el \u00edndice del bot\u00f3n (0\u20133) o -1.</p> <p>wait_button_blocking(): bloquea hasta detectar una pulsaci\u00f3n v\u00e1lida.</p> <p>d) Aleatoriedad y arranque</p> <p>wait_for_start_and_seed(): muestra 0 en el display y hace una animaci\u00f3n c\u00edclica de LEDs para indicar \u201clisto para empezar\u201d.</p> <p>Cuando detecta la primera pulsaci\u00f3n, siembra el RNG con: time_us_64() mezclado con el \u00edndice del bot\u00f3n; esto asegura secuencias distintas en cada partida.</p> <p>Hace una peque\u00f1a pausa para que esa pulsaci\u00f3n no cuente como entrada de juego.</p> <p>e) Juego por rondas</p> <p>pattern[MAX_STEPS]: secuencia aleatoria sobre {0,1,2,3}.</p> <p>Flujo por partida (en main()):</p> <p>Espera inicio y siembra RNG.</p> <p>Inicializa round_len = 0 y llena pattern con valores aleatorios (randi4()).</p> <p>Bucle de juego:</p> <p>Incrementa round_len (hasta MAX_STEPS).</p> <p>Muestra n\u00famero de ronda en el 7-seg (0\u20139 y luego A\u2013F).</p> <p>Reproduce la secuencia con play_sequence() (LEDs con blink).</p> <p>Entrada del jugador: por cada paso, espera bot\u00f3n con wait_button_blocking(), da feedback encendiendo el LED correspondiente (INPUT_LED_MS) y compara con pattern[i].</p> <p>Si hay error \u2192 game_over_anim(), termina la partida.</p> <p>Si completa MAX_STEPS \u2192 win_anim(), victoria.</p> <p>Bonus visual: parpadeo del \u00faltimo elemento correcto.</p> <p>Al terminar, vuelve a modo espera (display en 0, LEDs apagados).</p> <p>win_anim(): muestra letra U (m\u00e1scara SEG_U) como \u201cwin\u201d, secuencia de parpadeos y limpia display.</p> <p>f) Animaciones</p> <p>game_over_anim(): barridos y blinks de todos los LEDs, limpia display.</p>"},{"location":"SimonDice/#video","title":"Video","text":"<p>Video Pong</p>"},{"location":"Sistemas_embebidos/","title":"Sistemas embebidos","text":""},{"location":"Uart_LEDS/","title":"Comunicaci\u00f3n UART bidireccional con control de LED y bot\u00f3n (Raspberry Pi Pico)","text":"<p>Este proyecto implementa una comunicaci\u00f3n UART bidireccional entre dos Raspberry Pi Pico, donde una env\u00eda datos al presionar un bot\u00f3n, y la otra responde encendiendo o apagando un LED seg\u00fan el comando recibido. Advertencia: No conectar directamente a la red el\u00e9ctrica.</p>"},{"location":"Uart_LEDS/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Control de LED por UART bidireccional </li> <li>Autor: Rodrigo Z\u00e1rate </li> <li>Asignatura: Sistemas Embebidos </li> <li>Fecha: 28/10/2025 </li> <li>Descripci\u00f3n breve: Sistema de comunicaci\u00f3n serial entre dos Raspberry Pi Pico mediante UART, donde un bot\u00f3n env\u00eda comandos y el receptor ejecuta acciones como encender o apagar un LED, adem\u00e1s de enviar mensajes de retroalimentaci\u00f3n.</li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C++ con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>, <code>hardware/uart.h</code>). T\u00e9cnicas clave: Comunicaci\u00f3n UART, lectura digital de bot\u00f3n, control GPIO, procesamiento de cadenas y comandos. Plataforma: Raspberry Pi Pico / Pico 2.  </p>"},{"location":"Uart_LEDS/#material-utilizado","title":"Material utilizado","text":"<ul> <li>2 \u00d7 Raspberry Pi Pico (o Pico 2)  </li> <li>2 \u00d7 Cables USB  </li> <li>1 \u00d7 Bot\u00f3n (pushbutton)  </li> <li>1 \u00d7 LED + resistencia de 330 \u03a9  </li> <li>1 \u00d7 Resistencia de 10 k\u03a9 (pull-up)  </li> <li>Protoboard y cables jumper macho-macho  </li> </ul>"},{"location":"Uart_LEDS/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar una comunicaci\u00f3n UART confiable entre dos microcontroladores.  </li> <li>Enviar comandos de texto como <code>\"LEDON\"</code> y <code>\"LEDOFF\"</code> a trav\u00e9s de UART.  </li> <li>Detectar la presi\u00f3n de un bot\u00f3n y enviar mensajes autom\u00e1ticos.  </li> <li>Controlar un LED remoto en funci\u00f3n de los comandos recibidos.  </li> <li>Mostrar eco y retroalimentaci\u00f3n por consola serial.</li> </ul>"},{"location":"Uart_LEDS/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>Mapeo de pines seg\u00fan el c\u00f3digo principal:</p> Se\u00f1al Pico (TX) Pico (RX) Descripci\u00f3n <code>TX</code> GP0 \u2014 Transmisi\u00f3n UART <code>RX</code> \u2014 GP1 Recepci\u00f3n UART <code>GND</code> GND GND Tierra com\u00fan <p>Entradas y salidas:</p> Dispositivo GPIO Funci\u00f3n Bot\u00f3n 16 Entrada digital con <code>gpio_pull_up()</code> LED 15 Salida digital de control <p>Notas de conexi\u00f3n: - Conectar GP0 (TX) de una Pico al GP1 (RX) de la otra. - Compartir GND entre ambas placas. - Conectar LED en serie con resistencia de 330 \u03a9 al pin 15. - Bot\u00f3n conectado a GP16 con resistencia pull-up interna.</p> <p>Diagrama de conexi\u00f3n </p>"},{"location":"Uart_LEDS/#4-codigo-principal","title":"4) C\u00f3digo principal","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define button_pin 16\n#define led_PIN 15\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    gpio_init(button_pin);\n    gpio_set_dir(button_pin, GPIO_IN);\n    gpio_pull_up(button_pin);\n\n    gpio_init(led_PIN);\n    gpio_set_dir(led_PIN, GPIO_OUT);\n\n    string c = \"\";\n    string p = \"\";\n    int a = 1;\n\n    while (true) {\n\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            p += (char)ch;\n\n            if (ch == '.' || ch == '\\n') {\n                uart_puts(UART_ID, p.c_str());\n                p = \"\";\n            }\n        }\n\n        if (gpio_get(button_pin) == 0 &amp;&amp; a == 1) {\n            printf(\"Button pressed!\\n\");\n            uart_puts(UART_ID, \"LEDON\\n\");\n            sleep_ms(200);\n        }\n        a = gpio_get(button_pin);\n\n        if (uart_is_readable(uart0)) {\n            char character = uart_getc(uart0);\n            printf(\"%c\\n\", character);\n\n            if (character == '\\n' || character == '.') {\n                if (c == \"LEDON\") {\n                    gpio_put(led_PIN, 1);\n                    printf(\"LED is ON\\n\");\n                }\n                else if (c == \"LEDOFF\") {\n                    gpio_put(led_PIN, 0);\n                    printf(\"LED is OFF\\n\");\n                }\n                else if (c == \"Invalid Command\") {\n                    printf(\"Invalid Command\\n\");\n                }\n                else {\n                    uart_puts(UART_ID, \"Invalid Command\\n\");\n                }\n                c = \"\";\n                continue;\n            }\n            else {\n                c += character;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Uart_LEDS/#5-explicacion-del-codigo","title":"5) Explicacion del codigo","text":""},{"location":"Uart_LEDS/#a-comunicacion-uart","title":"a) Comunicaci\u00f3n UART","text":"<ul> <li>Se utiliza UART0 con los pines GP0 (TX) y GP1 (RX).  </li> <li>La velocidad de transmisi\u00f3n es 115200 bps, ideal para pruebas de eco y env\u00edo de cadenas.  </li> <li><code>uart_puts()</code> env\u00eda cadenas completas; <code>uart_getc()</code> recibe un car\u00e1cter a la vez.</li> </ul>"},{"location":"Uart_LEDS/#b-logica-del-boton","title":"b) L\u00f3gica del bot\u00f3n","text":"<ul> <li>El bot\u00f3n est\u00e1 configurado en GP16 con <code>gpio_pull_up()</code>.  </li> <li>Cuando se detecta una presi\u00f3n (lectura baja), se env\u00eda el comando <code>\"LEDON\\n\"</code> por UART.  </li> <li>Se incluye <code>sleep_ms(200)</code> para evitar rebotes y env\u00edos m\u00faltiples.</li> </ul>"},{"location":"Uart_LEDS/#c-logica-del-led","title":"c) L\u00f3gica del LED","text":"<ul> <li>Al recibir los comandos <code>\"LEDON\"</code> o <code>\"LEDOFF\"</code>, el microcontrolador enciende o apaga el LED (GPIO 15).  </li> <li>Si recibe un mensaje desconocido, env\u00eda <code>\"Invalid Command\\n\"</code> como retroalimentaci\u00f3n.</li> </ul>"},{"location":"Uart_LEDS/#d-mecanismo-de-eco","title":"d) Mecanismo de eco","text":"<ul> <li>Cualquier car\u00e1cter recibido desde teclado se reenv\u00eda (<code>printf(\"Eco: %c\\n\")</code>), \u00fatil para depuraci\u00f3n en consola.</li> </ul>"},{"location":"Uart_LEDS/#e-consideraciones-generales","title":"e) Consideraciones generales","text":"<ul> <li>Ambas Raspberry Pico deben compartir GND com\u00fan.  </li> <li>Los comandos deben terminar con punto (.) o salto de l\u00ednea (\\n) para ser interpretados.  </li> <li>La comunicaci\u00f3n es bidireccional, permitiendo confirmaci\u00f3n del estado.</li> </ul>"},{"location":"Uart_LEDS/#6-pruebas-y-comportamiento-esperado","title":"6) Pruebas y comportamiento esperado","text":"<ul> <li>Caso 1: Al presionar el bot\u00f3n, se env\u00eda <code>LEDON\\n</code>. El otro dispositivo enciende el LED y responde <code>\"LED is ON\"</code>.  </li> <li>Caso 2: Al escribir manualmente <code>LEDOFF</code> en la terminal, el LED se apaga.  </li> <li>Caso 3: Si se env\u00eda texto distinto, se recibe <code>\"Invalid Command\"</code>.  </li> <li>Caso 4: Si se desconecta GND, no hay respuesta ni encendido del LED.  </li> <li>Verificaci\u00f3n: En la consola se muestran los mensajes de eco y recepci\u00f3n en tiempo real.  </li> </ul> <p>Resultado esperado: Comunicaci\u00f3n UART estable y bidireccional con control remoto de un LED mediante bot\u00f3n f\u00edsico y comandos de texto.</p>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"control_pwm/","title":"Control de PWM","text":"Perif\u00e9ricos, Memoria, Ecosistema, Costos, Arquitectura y Velocidad de Trabajo"},{"location":"control_pwm/#informacion","title":"Informacion","text":"<ul> <li>Nombre del proyecto: Control de pwm con Raspberry Pico</li> <li>Equipo / Autor(es): Rodrigo Zarate </li> <li>Curso / Asignatura: Sistemas Embebidos</li> <li>Fecha: 23/08/2025</li> <li>Descripci\u00f3n breve: Implementaci\u00f3n de un sistema de generaci\u00f3n de audio con buzzer pasivo usando control PWM en el microcontrolador RP2040 (Raspberry Pi Pico). Se documentan los perif\u00e9ricos utilizados y se ubica al RP2040 en una comparativa con otros MCUs.</li> </ul>"},{"location":"control_pwm/#introduccion-control-pwm","title":"Introducci\u00f3n: Control PWM","text":"<p>En este proyecto se emplea el m\u00f3dulo PWM (Pulse Width Modulation) del microcontrolador RASPBERRY PICO para generar se\u00f1ales de audio en un buzzer pasivo. El principio consiste en variar la frecuencia de la se\u00f1al cuadrada enviada al buzzer, de manera que \u00e9ste reproduzca diferentes notas musicales.  </p> <p>El c\u00f3digo define una lista de notas (frecuencias en Hz) y figuras r\u00edtmicas (divisiones de tiempo), que son enviadas al perif\u00e9rico PWM del RP2040 para reproducir una melod\u00eda.  </p> <p>Este enfoque demuestra c\u00f3mo los perif\u00e9ricos de un microcontrolador pueden ser usados no solo para control de motores o regulaci\u00f3n de voltaje, sino tambi\u00e9n para la generaci\u00f3n de sonidos y m\u00fasica digital.</p>"},{"location":"control_pwm/#perifericos","title":"Perif\u00e9ricos","text":"<ul> <li>RASPBERRY PICO     Se utiliza la Raspberry Pi Pico porque integra el microcontrolador RP2040, que cuenta con perif\u00e9ricos PWM de hardware dedicados. Esto permite generar se\u00f1ales de modulaci\u00f3n por ancho de pulso de manera precisa y eficiente, sin sobrecargar el procesador principal. Adem\u00e1s, la Pico es econ\u00f3mica, f\u00e1cil de programar y ampliamente soportada por la comunidad, lo que facilita el desarrollo y la depuraci\u00f3n de proyectos de control de se\u00f1ales como este.</li> </ul>"},{"location":"control_pwm/#ecosistema","title":"Ecosistema","text":"<p>El RP2040 cuenta con un ecosistema creciente y robusto:  </p> <ul> <li>Lenguajes soportados: C/C++ (usando SDK oficial) y MicroPython.  </li> <li>IDE y entornos comunes: VSCode, Thonny, Arduino IDE (con soporte agregado).  </li> </ul>"},{"location":"control_pwm/#velocidad-de-trabajo","title":"Velocidad de Trabajo","text":"<ul> <li>La Pico opera a 150 MHz, lo cual resulta sobrado para generar PWM de audio.  </li> <li>El c\u00e1lculo del divisor para el perif\u00e9rico PWM (<code>pwm_set_clkdiv_int_frac()</code>) se hace r\u00e1pidamente gracias a la alta frecuencia de reloj.  </li> <li>En este proyecto, la frecuencia m\u00e1xima usada fue ~2 kHz (notas musicales), muy por debajo del l\u00edmite real del microcontrolador.  </li> </ul>"},{"location":"control_pwm/#codigo-del-buzzer","title":"Codigo del buzzer","text":"<p>```c</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n\n#define BUZZER_PIN 15\n#define BPM 200           \n#define GAP_MS 12\n\n// notes en hz\n#define NOTE_B0  31\n#define NOTE_C1  33\n#define NOTE_CS1 35\n#define NOTE_D1  37\n#define NOTE_DS1 39\n#define NOTE_E1  41\n#define NOTE_F1  44\n#define NOTE_FS1 46\n#define NOTE_G1  49\n#define NOTE_GS1 52\n#define NOTE_A1  55\n#define NOTE_AS1 58\n#define NOTE_B1  62\n#define NOTE_C2  65\n#define NOTE_CS2 69\n#define NOTE_D2  73\n#define NOTE_DS2 78\n#define NOTE_E2  82\n#define NOTE_F2  87\n#define NOTE_FS2 93\n#define NOTE_G2  98\n#define NOTE_GS2 104\n#define NOTE_A2  110\n#define NOTE_AS2 117\n#define NOTE_B2  123\n#define NOTE_C3  131\n#define NOTE_CS3 139\n#define NOTE_D3  147\n#define NOTE_DS3 156\n#define NOTE_E3  165\n#define NOTE_F3  175\n#define NOTE_FS3 185\n#define NOTE_G3  196\n#define NOTE_GS3 208\n#define NOTE_A3  220\n#define NOTE_AS3 233\n#define NOTE_B3  247\n#define NOTE_C4  262\n#define NOTE_CS4 277\n#define NOTE_D4  294\n#define NOTE_DS4 311\n#define NOTE_E4  330\n#define NOTE_F4  349\n#define NOTE_FS4 370\n#define NOTE_G4  392\n#define NOTE_GS4 415\n#define NOTE_A4  440\n#define NOTE_AS4 466\n#define NOTE_B4  494\n#define NOTE_C5  523\n#define NOTE_CS5 554\n#define NOTE_D5  587\n#define NOTE_DS5 622\n#define NOTE_E5  659\n#define NOTE_F5  698\n#define NOTE_FS5 740\n#define NOTE_G5  784\n#define NOTE_GS5 831\n#define NOTE_A5  880\n#define NOTE_AS5 932\n#define NOTE_B5  988\n#define NOTE_C6  1047\n#define NOTE_CS6 1109\n#define NOTE_D6  1175\n#define NOTE_DS6 1245\n#define NOTE_E6  1319\n#define NOTE_F6  1397\n#define NOTE_FS6 1480\n#define NOTE_G6  1568\n#define NOTE_GS6 1661\n#define NOTE_A6  1760\n#define NOTE_AS6 1865\n#define NOTE_B6  1976\n\n#define REST 0\n\n// ====== Figuras (divisor del pulso) ======\n// Duraci\u00f3n real (ms) = (60000 / BPM) * 4 / FIG\n#define W   1   // redonda (4 tiempos)\n#define H   2   // blanca   (2 tiempos)\n#define Q   4   // negra    (1 tiempo)\n#define E   8   // corchea  (1/2)\n#define S   16  // semicor. (1/4)\n#define T32 32  // fusa\n\n// ====== PWM helper ======\nstatic void pwm_set_freq_duty(uint pin, uint32_t freq, float duty_percent) {\n    gpio_set_function(pin, GPIO_FUNC_PWM); // seteamos la funcion del pin a PWM\n    uint slice = pwm_gpio_to_slice_num(pin); //Cambiar la funcioin de GPIO a PWM\n    uint chan  = pwm_gpio_to_channel(pin); //Asignamos el canal\n\n    if (freq == 0) {\n        pwm_set_enabled(slice, false);\n        return;\n    }\n\n    //Aqui empezamos a calcular el divisor\n\n    uint32_t f_sys = 150000000u; // la frecuencia del pico\n    uint32_t top = 4095; // aqui pensamos esto para usar 12 bits, pues tenemos la formula log2(top +1)\n    float div = (float)f_sys / (freq * (top + 1));\n\n    //esto es solo por si se sale de rano el divisor\n    if (div &lt; 1.0f) div = 1.0f;          // l\u00edmite inferior ( pues solo tiene un rango el pwm de 1 a 255)\n    if (div &gt; 255.0f) div = 255.0f;      // l\u00edmite superior\n\n    uint32_t div_int  = (uint32_t)div; //dividimos div en su parte entera\n    uint32_t div_frac = (uint32_t)((div - div_int) * 16.0f); // y esta es su parte fraccionaria\n    //basicamente se define div que se usar\u00e1\n\n\n    pwm_set_clkdiv_int_frac(slice, div_int, div_frac); //seteamos el divisor, esta es como la funcion pwm_set_clkdiv pero con parte fraccionaria\n    pwm_set_wrap(slice, top);//seteamos el top\n\n    uint32_t level = (uint32_t)(duty_percent * 0.01f * (top + 1));\n    pwm_set_chan_level(slice, chan, level);\n    pwm_set_enabled(slice, true);\n}\n\nstatic inline uint32_t ms_per_whole(void) {\n    // para la duracion de una redonda \n    return (60000u / BPM) * 4u;\n}\n\nstatic void play(uint32_t freq, uint32_t figure_div) {\n    uint32_t dur_ms = ms_per_whole() / figure_div;\n    if (freq == REST) {\n        pwm_set_freq_duty(BUZZER_PIN, 0, 0);\n        sleep_ms(dur_ms);\n    } else {\n        pwm_set_freq_duty(BUZZER_PIN, freq, 50.0f);\n\n        sleep_ms(dur_ms);\n        pwm_set_freq_duty(BUZZER_PIN, 0, 0);\n\n    }\n}\n\n\nstatic const uint16_t melody[] = {\n    // Frase A\n    NOTE_D4, NOTE_D4, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4, \n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //B\n    NOTE_C4, NOTE_C4, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //C\n    NOTE_A3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //D \n    NOTE_AS3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n\n    //REPEAT 2\n    NOTE_D4, NOTE_D4, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4, \n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //B\n    NOTE_C4, NOTE_C4, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //C\n    NOTE_A3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //D \n    NOTE_AS3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n\n    //siguiente f   \n    NOTE_AS3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    // G\n    NOTE_C5, NOTE_C5, NOTE_C6,\n    NOTE_A4, REST, NOTE_GS6,REST,\n    NOTE_G5, NOTE_F5,\n    NOTE_F5,NOTE_C5,NOTE_F5,NOTE_G5,\n    //H\n    NOTE_C5, NOTE_C5, NOTE_C6,\n    NOTE_A4, REST, NOTE_GS6,REST,\n    NOTE_G5, NOTE_F5,\n    NOTE_F5,NOTE_C5,NOTE_F5,NOTE_G5,\n    //x2\n    NOTE_C5, NOTE_C5, NOTE_C6,\n    NOTE_A4, REST, NOTE_GS6,REST,\n    NOTE_G5, NOTE_F5,\n    NOTE_F5,NOTE_C5,NOTE_F5,NOTE_G5,\n    //H\n    NOTE_C5, NOTE_C5, NOTE_C6,\n    NOTE_A4, REST, NOTE_GS6,REST,\n    NOTE_G5, NOTE_F5,\n    NOTE_F5,NOTE_C5,NOTE_F5,NOTE_G5,\n\n\n\n\n\n};\n\nstatic const uint8_t rhythm[] = {\n    // Frase A\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    /// Frase B\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //FRASE C\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //FRASE D\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n\n    //REPEAT 2\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    /// Frase B\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //FRASE C\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //FRASE D\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //siguiente f   \n    E, E, Q,  \n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    // G\n    E,E,Q,\n    Q,E,E,E,\n    Q,E,\n    E,E,E,E,\n    //H\n    E,E,Q,\n    Q,E,E,E,\n    Q,E,\n    E,E,E,E,\n    //x2\n    E,E,Q,\n    Q,E,E,E,\n    Q,E,\n    E,E,E,E,\n    //H\n    E,E,Q,\n    Q,E,E,E,\n    Q,E,\n    E,E,E,E\n\n\n\n\n\n};\n\n\n// ====== main ======\nint main() {\n    stdio_init_all();\n    gpio_init(BUZZER_PIN);\n    gpio_set_dir(BUZZER_PIN, true);\n\n    const int notes = sizeof(melody) / sizeof(melody[0]);\n\n    while (true) {\n        for (int i = 0; i &lt; notes; ++i) {\n            play(melody[i], rhythm[i]);\n        }\n        sleep_ms(800);  // breve pausa antes de repetir\n    }\n    return 0;\n}\n</code></pre>"},{"location":"control_pwm/#explicacion","title":"Explicaci\u00f3n","text":""},{"location":"control_pwm/#que-hace-playfreq-figure_div","title":"\u00bfQu\u00e9 hace <code>play(freq, figure_div)</code>?","text":"<p>Funci\u00f3n que toca una nota (o un silencio) en un buzzer mediante PWM durante el tiempo correspondiente a la figura r\u00edtmica.</p>"},{"location":"control_pwm/#parametros","title":"Par\u00e1metros","text":"<ul> <li><code>freq</code>: frecuencia de la nota en Hz. Si es <code>REST</code>, se reproduce silencio.</li> <li><code>figure_div</code>: divisor de la figura musical (1=redonda, 2=blanca, 4=negra, 8=corchea, etc.).</li> </ul>"},{"location":"control_pwm/#flujo-de-ejecucion","title":"Flujo de ejecuci\u00f3n","text":"<ol> <li>Duraci\u00f3n: calcula <code>dur_ms = ms_per_whole() / figure_div</code>, usando el BPM para obtener la duraci\u00f3n de una redonda y dividirla por la figura indicada.</li> <li>Silencio (REST):</li> <li>Si <code>freq == REST</code>, apaga el PWM (<code>pwm_set_freq_duty(..., 0, 0)</code>) y espera <code>dur_ms</code>.</li> <li>Nota:</li> <li>Enciende el PWM con la frecuencia <code>freq</code> y duty 50% (<code>pwm_set_freq_duty(BUZZER_PIN, freq, 50.0f)</code>), generando una onda cuadrada sim\u00e9trica.</li> <li>Mantiene la nota con <code>sleep_ms(dur_ms)</code>.</li> <li>Apaga el PWM al final para garantizar silencio.</li> </ol>"},{"location":"control_pwm/#claves","title":"Claves","text":"<ul> <li>La frecuencia define el pitch (altura de la nota).</li> <li>El duty 50% ofrece buen equilibrio de volumen/timbre para un buzzer pasivo.</li> <li>Implementaci\u00f3n bloqueante: <code>sleep_ms(...)</code> detiene la CPU durante la nota/silencio.</li> <li>Versi\u00f3n m\u00ednima: no incluye micro-silencios de articulaci\u00f3n ni envolventes (ataque/decay).</li> </ul>"},{"location":"control_pwm/#referencias","title":"Referencias","text":""},{"location":"control_pwm/#video","title":"Video","text":"<ul> <li>Raspberry Pi Ltd. (2025). RP2040 Datasheet. Disponible en: https://www.raspberrypi.com/documentation/microcontrollers/rp2040.html </li> <li>C\u00f3digo de pr\u00e1ctica en C (PWM con buzzer), desarrollado por el autor (2025).  </li> <li>Espressif Systems, STMicroelectronics, NXP, Microchip, Texas Instruments \u2013 Datasheets oficiales de referencia.  </li> </ul>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"pwm_motor/","title":"Control de motor DC por PWM (3 velocidades) con botones (Raspberry Pi Pico + TB6612FNG)","text":"<p>Este proyecto controla la velocidad de un motor DC mediante PWM usando un Raspberry Pi Pico/Pico 2 y el driver TB6612FNG. Dos botones (SUBIR/BAJAR) cambian entre tres niveles de velocidad predefinidos. El PWM trabaja a 20 kHz (fuera del rango audible).</p>"},{"location":"pwm_motor/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Motor DC PWM 3 velocidades </li> <li>Equipo / Autor(es): Rodrigo Zarate </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 01/10/2025 </li> <li>Descripci\u00f3n breve: Control de un motor DC con TB6612FNG usando PWM (20 kHz) y dos botones con _pull-up interno para seleccionar 3 niveles de velocidad (70%, 80%, 90%)._  </li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>, <code>hardware/pwm.h</code>). T\u00e9cnicas clave: PWM (20 kHz), c\u00e1lculo de <code>clkdiv</code> y <code>wrap</code>, debounce por software, lectura de GPIO con pull-up y detecci\u00f3n de flanco. Plataforma: Raspberry Pi Pico / Pico 2.  </p>"},{"location":"pwm_motor/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico (o Pico 2) y cable USB  </li> <li>Driver TB6612FNG </li> <li>Motor DC (compatible con la tensi\u00f3n de VM y corriente del driver)  </li> <li>Fuente de VM (ej. 5\u201312 V seg\u00fan motor)  </li> <li>2 botones moment\u00e1neos (a GND, sin resistencias externas gracias al pull-up interno)  </li> <li>Protoboard y jumpers</li> </ul>"},{"location":"pwm_motor/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar PWM a 20 kHz sobre un pin GPIO para modular la velocidad del motor.  </li> <li>Implementar tres velocidades predefinidas con cambios mediante dos botones (subir/bajar).  </li> <li>Aplicar debounce por software y detecci\u00f3n de flanco 1\u21920.  </li> <li>Fijar direcci\u00f3n de giro con pines AIN1/AIN2 (TB6612FNG).</li> </ul>"},{"location":"pwm_motor/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>Notas generales (TB6612FNG): - PWMA controla el canal A (ancho de pulso). - AIN1/AIN2 fijan la direcci\u00f3n del canal A. - AO1/AO2 salen al motor. - VM: alimentaci\u00f3n del motor (p. ej. 6\u201312 V). - VCC: 3V3 l\u00f3gicos desde el Pico. - GND com\u00fan entre Pico, TB6612 y la fuente del motor. - STBY: mantener en alto (3V3) para habilitar el driver.</p> <p>Mapeo de pines (seg\u00fan el c\u00f3digo):</p> Se\u00f1al (Pico) GPIO TB6612FNG Descripci\u00f3n <code>PWM_PIN</code> 0 PWMA PWM 20 kHz (control de velocidad) <code>DIR1_PIN</code> 16 AIN1 Direcci\u00f3n (bit 1) <code>DIR2_PIN</code> 17 AIN2 Direcci\u00f3n (bit 2) <code>BTN_DOWN_PIN</code> 2 \u2014 Bot\u00f3n BAJAR (a GND, pull-up) <code>BTN_UP_PIN</code> 3 \u2014 Bot\u00f3n SUBIR (a GND, pull-up) <p>Botones (activos en bajo): - Un terminal del bot\u00f3n a GND; el otro a GPIO 2 (BAJAR) o GPIO 3 (SUBIR). - Se habilita <code>gpio_pull_up()</code>, por lo que al presionar: 0 l\u00f3gico.</p> <p>Direcci\u00f3n fija (ejemplo): - <code>AIN1=1</code> y <code>AIN2=0</code> (definido en el c\u00f3digo) \u2192 giro adelante. - Para invertir el giro: intercambia los valores o cablea al rev\u00e9s.</p> <p>Diagrama de conexi\u00f3n </p>"},{"location":"pwm_motor/#4-codigo","title":"4) C\u00f3digo","text":"<p>```c     // dc_motor_pwm.c \u2014 Control de motor DC con 3 velocidades (baja/media/alta)     // Raspberry Pi Pico / Pico 2 + TB6612FNG (ejemplo)     // PWM en GPIO15 \u2192 PWMA; Direcci\u00f3n: AIN1 (GPIO16), AIN2 (GPIO17)     // Botones a GND con pull-up interno: BTN_DOWN(GPIO13), BTN_UP(GPIO14)</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n// ----------------- Pines -----------------\n#define PWM_PIN      0       // PWMA (TB6612)\n#define DIR1_PIN     16     // AIN1\n#define DIR2_PIN     17     // AIN2\n#define BTN_DOWN_PIN 2     // Bot\u00f3n: bajar velocidad\n#define BTN_UP_PIN   3     // Bot\u00f3n: subir velocidad\n\n// ----------------- PWM -------------------\n#define F_PWM_HZ  20000     // 20 kHz: fuera de audio\n#define TOP       1023      // 10 bits de resoluci\u00f3n (0..1023)\n\n// ----------------- Debounce --------------\n#define DEBOUNCE_MS 30\n\nint main() {\n    stdio_init_all();\n\n// --- Direcci\u00f3n: adelante (AIN1=1, AIN2=0) ---\ngpio_init(DIR1_PIN); gpio_set_dir(DIR1_PIN, GPIO_OUT); gpio_put(DIR1_PIN, 1);\ngpio_init(DIR2_PIN); gpio_set_dir(DIR2_PIN, GPIO_OUT); gpio_put(DIR2_PIN, 0);\n\n// --- Botones con pull-up interno (activos en 0) ---\ngpio_init(BTN_DOWN_PIN); gpio_set_dir(BTN_DOWN_PIN, GPIO_IN); gpio_pull_up(BTN_DOWN_PIN);\ngpio_init(BTN_UP_PIN);   gpio_set_dir(BTN_UP_PIN,   GPIO_IN); gpio_pull_up(BTN_UP_PIN);\n\n// --- PWM en el pin de control de velocidad ---\ngpio_set_function(PWM_PIN, GPIO_FUNC_PWM);\nuint slice = pwm_gpio_to_slice_num(PWM_PIN);\nuint chan  = pwm_gpio_to_channel(PWM_PIN);\n\nfloat f_clk = 150000000.0f;                         // 125 MHz\nfloat div   = f_clk / (F_PWM_HZ * (TOP + 1));       // clkdiv flotante\npwm_set_clkdiv(slice, div);\npwm_set_wrap(slice, TOP);\n\npwm_set_chan_level(slice, chan, 0);                 // arranque detenido\npwm_set_enabled(slice, true);\n\n// --- Tabla de 3 velocidades (duty) ---\n// Baja=35%, Media=65%, Alta=90%\nuint16_t speed_levels[] = {\n    (uint16_t)(TOP * 0.70f),\n    (uint16_t)(TOP * 0.80f),\n    (uint16_t)(TOP * 0.90f)\n};\nconst int NUM_SPEEDS = 3;\n\nint idx = 0; // \u00edndice de velocidad actual (0=baja)\nuint32_t t_last_down = 0, t_last_up = 0;\nint last_down = 1, last_up = 1; // estados anteriores (con pull-up, reposo=1)\n\n// Aplica velocidad inicial\npwm_set_chan_level(slice, chan, speed_levels[idx]);\n\nwhile (true) {\n    // --- Leer botones (con edge + debounce) ---\n    int cur_down = gpio_get(BTN_DOWN_PIN);\n    int cur_up   = gpio_get(BTN_UP_PIN);\n    uint32_t now = to_ms_since_boot(get_absolute_time());\n\n    // Bot\u00f3n DOWN: flanco de 1-&gt;0\n    if (last_down == 1 &amp;&amp; cur_down == 0 &amp;&amp; (now - t_last_down) &gt; DEBOUNCE_MS) {\n        if (idx &gt; 0) idx--;\n        pwm_set_chan_level(slice, chan, speed_levels[idx]);\n        t_last_down = now;\n    }\n    // Bot\u00f3n UP: flanco de 1-&gt;0\n    if (last_up == 1 &amp;&amp; cur_up == 0 &amp;&amp; (now - t_last_up) &gt; DEBOUNCE_MS) {\n        if (idx &lt; (NUM_SPEEDS - 1)) idx++;\n        pwm_set_chan_level(slice, chan, speed_levels[idx]);\n        t_last_up = now;\n    }\n\n    last_down = cur_down;\n    last_up   = cur_up;\n\n    sleep_ms(5);\n}\n</code></pre> <p>}</p>"},{"location":"pwm_motor/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"pwm_motor/#a-configuracion-de-pwm-20-khz-10-bits","title":"a) Configuraci\u00f3n de PWM (20 kHz, 10 bits)","text":"<ul> <li><code>F_PWM_HZ = 20000</code> y <code>TOP = 1023</code> \u2192 resoluci\u00f3n de 10 bits (0..1023).</li> <li>Se calcula <code>clkdiv</code> con <code>div = f_clk / (F_PWM_HZ * (TOP + 1))</code>.</li> <li>Nota: En el c\u00f3digo <code>f_clk = 150e6</code> con comentario \u201c125 MHz\u201d. Ajusta el valor si tu reloj es 125 MHz (<code>125000000.0f</code>) o deja 150 MHz si realmente configuraste el PLL a esa frecuencia.</li> <li><code>pwm_set_wrap(slice, TOP)</code> y <code>pwm_set_clkdiv(slice, div)</code> fijan la frecuencia.</li> <li><code>pwm_set_chan_level(slice, chan, duty)</code> actualiza el ciclo de trabajo.</li> </ul>"},{"location":"pwm_motor/#b-direccion-del-motor-tb6612fng","title":"b) Direcci\u00f3n del motor (TB6612FNG)","text":"<ul> <li>Se fuerza adelante con <code>AIN1=1</code>, <code>AIN2=0</code>.</li> <li>Para invertir el giro: <code>AIN1=0</code>, <code>AIN2=1</code>. No uses <code>0/0</code> (rueda libre) ni <code>1/1</code> (freno) salvo intencionalmente.</li> </ul>"},{"location":"pwm_motor/#c-botones-con-pull-up-y-debounce","title":"c) Botones con pull-up y debounce","text":"<ul> <li><code>BTN_DOWN_PIN</code> (GPIO 2) y <code>BTN_UP_PIN</code> (GPIO 3) como entradas con <code>gpio_pull_up()</code>.</li> <li>Se detecta flanco 1\u21920 (presi\u00f3n) comparando estado previo/actual.</li> <li>Debounce: <code>DEBOUNCE_MS = 30</code> ms por bot\u00f3n con marcas de tiempo (<code>to_ms_since_boot</code>).</li> </ul>"},{"location":"pwm_motor/#d-tabla-de-velocidades","title":"d) Tabla de velocidades","text":"<ul> <li>Niveles en <code>speed_levels[]</code>: 70%, 80%, 90% del <code>TOP</code>.</li> <li>Nota: El comentario dice \u201c35/65/90%\u201d, pero el c\u00f3digo actual aplica 70/80/90%. Cambia los coeficientes <code>0.70f, 0.80f, 0.90f</code> si deseas otros niveles (p. ej., <code>0.35f, 0.65f, 0.90f</code>).</li> <li><code>idx</code> selecciona el nivel. Los botones BAJAR/SUBIR decrementan/incrementan <code>idx</code> dentro de <code>[0, NUM_SPEEDS-1]</code>.</li> </ul>"},{"location":"pwm_motor/#e-bucle-principal","title":"e) Bucle principal","text":"<ul> <li>Lee botones, aplica debounce, actualiza <code>idx</code> si hay flanco v\u00e1lido y reprograma el duty con <code>pwm_set_chan_level</code>.</li> <li><code>sleep_ms(5)</code> fija la cadencia de sondeo (~200 Hz), suficiente para la interfaz de botones.</li> </ul>"},{"location":"pwm_motor/#6-pruebas-y-comportamiento-esperado","title":"6) Pruebas y comportamiento esperado","text":"<ul> <li>Arranque: motor en marcha a la velocidad 0 (70%).</li> <li>Bot\u00f3n SUBIR (GPIO 3): incrementa a 80% y luego 90%.</li> <li>Bot\u00f3n BAJAR (GPIO 2): decrementa hacia 80% y 70%.</li> <li>Debounce estable: pulsaciones r\u00e1pidas no deben generar m\u00faltiples cambios espurios.</li> <li>Silencio el\u00e9ctrico: PWM a 20 kHz evita zumbidos audibles en la mayor\u00eda de motores.</li> </ul>"},{"location":"seno_pwm/","title":"Senoide aproximada de 60 Hz por PWM (Raspberry Pi Pico)","text":"<p>Este proyecto genera una se\u00f1al senoidal \u201cpromediada\u201d de 60 Hz modulando el duty cycle de una portadora PWM a 40 kHz (10 bits). Se actualiza el duty en 128 muestras por ciclo, logrando un valor medio (tras filtrado o por inercia de la carga) que sigue una senoide. \u00datil para pruebas de filtrado RC, control de potencia (baja tensi\u00f3n) o caracterizaci\u00f3n de etapas H-bridge (aisladas). No conectar a la red el\u00e9ctrica.</p>"},{"location":"seno_pwm/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: PWM \u2192 senoide de 60 Hz </li> <li>Equipo / Autor(es): Rodrigo Zarate </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 01/10/2025 </li> <li>Descripci\u00f3n breve: S\u00edntesis de una senoide de 60 Hz mediante modulaci\u00f3n del duty de un PWM a 40 kHz con 10 bits y 128 muestras por ciclo. Timing con <code>sleep_until()</code> para reducir jitter. </li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>, <code>pico/time.h</code>, <code>hardware/pwm.h</code>). T\u00e9cnicas clave: PWM de alta frecuencia, tabla/muestreo senoidal, temporizaci\u00f3n absoluta (bajo jitter), cuantizaci\u00f3n 10 bits. Plataforma: Raspberry Pi Pico / Pico 2.  </p>"},{"location":"seno_pwm/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico (o Pico 2) y cable USB  </li> <li>Protoboard y jumpers  </li> <li>(Opcional) Filtro RC pasabajas (p. ej., R=1\u20134.7 k\u03a9, C=4.7\u201310 \u00b5F) para recuperar la senoide promedio  </li> <li>(Opcional) Osciloscopio para visualizar portadora y se\u00f1al filtrada  </li> <li>(Si se usa potencia) Etapa H-bridge/l\u00ednea aislada, nunca a red AC</li> </ul>"},{"location":"seno_pwm/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar PWM a 40 kHz con 10 bits de resoluci\u00f3n.  </li> <li>Generar una senoide de 60 Hz modulando el duty con 128 muestras/ciclo.  </li> <li>Usar temporizaci\u00f3n absoluta (<code>sleep_until</code>) para minimizar jitter de muestreo.  </li> <li>Controlar amplitud (<code>AMP_PCT</code>) y offset DC (<code>DC_OFFSET</code>) de la se\u00f1al promediada.</li> </ul>"},{"location":"seno_pwm/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>Mapeo de pines (seg\u00fan el c\u00f3digo):</p> Se\u00f1al (Pico) GPIO Descripci\u00f3n <code>PWM_PIN</code> 15 Salida PWM (portadora 40 kHz, duty variable) <code>GND</code> \u2014 Referencia com\u00fan <p>Notas de conexi\u00f3n: - Para observar la senoide promedio, conecta <code>PWM_PIN</code> a un filtro RC pasabajas y mide en la salida del filtro respecto a GND. - Ajusta el corte del RC (p. ej., 300\u2013800 Hz) para atenuar la portadora (40 kHz) preservando 60 Hz.</p> <p>Diagrama de conexi\u00f3n </p>"},{"location":"seno_pwm/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>```c\n// pwm_sine_60hz.c \u2014 Senoide aproximada de 60 Hz modulando el duty del PWM\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define PWM_PIN             15      // GPIO de salida PWM\n#define F_PWM_HZ            40000   // Portadora PWM (40 kHz, fuera de audio)\n#define TOP                 1023    // 10 bits de resoluci\u00f3n\n\n#define SINE_FREQ_HZ        60      // Frecuencia de la senoide \u201cpromediada\u201d\n#define SAMPLES_PER_CYCLE   128     // Muestras por ciclo de seno\n#define AMP_PCT             0.98f   // Amplitud relativa (0..1)\n#define DC_OFFSET           0.50f   // Offset DC relativo (0.5 = centrado)\n\nint main() {\n    stdio_init_all();\n\n    // --- Configurar PWM en el pin ---\n    gpio_set_function(PWM_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWM_PIN);\n    uint chan  = pwm_gpio_to_channel(PWM_PIN);\n\n    // Calcular divisor para la portadora\n    float f_clk = 125000000.0f;                    // 125 MHz\n    float div   = f_clk / (F_PWM_HZ * (TOP + 1));  // clkdiv flotante\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    // --- Generaci\u00f3n de seno por software (duty = sin()) ---\n    const float fs = (float)SINE_FREQ_HZ * (float)SAMPLES_PER_CYCLE;   // tasa de actualizaci\u00f3n\n    const uint32_t Ts_us = (uint32_t)lrintf(1000000.0f / fs);          // periodo de muestreo en us\n\n    float phase = 0.0f;\n    const float phase_step = 2.0f * (float)M_PI / (float)SAMPLES_PER_CYCLE;\n\n    // Reloj base para minimizar jitter\n    absolute_time_t t = delayed_by_us(get_absolute_time(), Ts_us);\n\n    while (true) {\n        // s \u2208 [-1,1] \u2192 u \u2208 [0,1] con offset y amplitud\n        float s = sinf(phase);\n        float u = DC_OFFSET + 0.5f * AMP_PCT * s;\n        if (u &lt; 0.0f) u = 0.0f; if (u &gt; 1.0f) u = 1.0f;\n\n        uint16_t level = (uint16_t)lrintf(u * (float)TOP);\n        pwm_set_chan_level(slice, chan, level);\n\n        // Avanzar fase y temporizaci\u00f3n precisa\n        phase += phase_step;\n        if (phase &gt;= 2.0f * (float)M_PI) phase -= 2.0f * (float)M_PI;\n\n        sleep_until(t);\n        t = delayed_by_us(t, Ts_us);\n    }\n}\n</code></pre>"},{"location":"seno_pwm/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"seno_pwm/#a-portadora-pwm-40-khz-10-bits","title":"a) Portadora PWM (40 kHz, 10 bits)","text":"<ul> <li><code>F_PWM_HZ = 40000</code> y <code>TOP = 1023</code> \u2192 10 bits (niveles 0..1023).</li> <li>Frecuencia de PWM mediante <code>div = f_clk / (F_PWM_HZ*(TOP+1))</code> con <code>f_clk = 125 MHz</code>.</li> <li><code>pwm_set_wrap(slice, TOP)</code> define el conteo y <code>pwm_set_clkdiv(slice, div)</code> ajusta el preescalador.</li> <li>El duty se actualiza con <code>pwm_set_chan_level(slice, chan, level)</code>.</li> </ul>"},{"location":"seno_pwm/#b-senoide-promedio-de-60-hz-muestreo-a-768-khz","title":"b) Senoide \u201cpromedio\u201d de 60 Hz (muestreo a 7.68 kHz)","text":"<ul> <li><code>SINE_FREQ_HZ = 60</code>, <code>SAMPLES_PER_CYCLE = 128</code> \u2192 <code>fs = 60\u00d7128 = 7680 Hz</code>.</li> <li>Periodo de muestra: <code>Ts_us \u2248 1e6 / 7680 \u2248 130.21 \u00b5s</code> (redondeado con <code>lrintf</code>).</li> <li>Se incrementa la fase en <code>phase_step = 2\u03c0/128</code> por muestra y se calcula <code>u = DC_OFFSET + 0.5\u00b7AMP_PCT\u00b7sin(phase)</code> limitado a <code>[0,1]</code>.</li> <li><code>u</code> se mapea a 10 bits: <code>level = round(u\u00b7TOP)</code>.</li> </ul>"},{"location":"seno_pwm/#c-temporizacion-precisa-bajo-jitter","title":"c) Temporizaci\u00f3n precisa (bajo jitter)","text":"<ul> <li>Se emplea un reloj absoluto: <code>sleep_until(t); t = delayed_by_us(t, Ts_us);</code> en vez de <code>sleep_us(Ts_us)</code>.</li> <li>Esto mantiene un periodo constante de actualizaci\u00f3n de duty, reduciendo el jitter de muestreo.</li> </ul>"},{"location":"seno_pwm/#d-control-de-amplitud-y-offset","title":"d) Control de amplitud y offset","text":"<ul> <li><code>AMP_PCT</code> (0..1) escala la amplitud pico a pico de la senoide promedio (aqu\u00ed 98%).</li> <li><code>DC_OFFSET = 0.5</code> centra la se\u00f1al en 50% de duty (salida bipolar tras filtro/etapa diferencial).</li> <li>Para una salida puramente unipolar filtrada, mantiene <code>DC_OFFSET \u2265 AMP_PCT/2</code>.</li> </ul>"},{"location":"seno_pwm/#e-recuperacion-de-la-senoide-filtro","title":"e) Recuperaci\u00f3n de la senoide (filtro)","text":"<ul> <li>Para observar una senoide limpia, usa un filtro pasabajas (p. ej., RC con <code>fc\u2248300\u2013800 Hz</code>).</li> <li>La portadora a 40 kHz queda muy atenuada; se conserva la envolvente de 60 Hz.</li> </ul>"},{"location":"seno_pwm/#6-pruebas-y-comportamiento-esperado","title":"6) Pruebas y comportamiento esperado","text":"<ul> <li>Osciloscopio (PWM crudo): tren a 40 kHz cuyo duty va oscilando suavemente.</li> <li>Tras RC: se\u00f1al aproximada a senoide 60 Hz; amplitud depende de <code>AMP_PCT</code>, offset seg\u00fan <code>DC_OFFSET</code>.</li> <li>Estabilidad temporal: la frecuencia de 60 Hz es estable por el uso de <code>sleep_until</code>.</li> <li>Ajustes r\u00e1pidos: cambiar <code>SAMPLES_PER_CYCLE</code> mejora la suavidad (m\u00e1s muestras) a costa de mayor tasa de actualizaci\u00f3n.</li> </ul>"},{"location":"timer/","title":"Parpadeo de 4 LEDs con System Timer (RP2350 / Pico 2)","text":""},{"location":"timer/#resumen","title":"Resumen","text":"<p>Este programa usa las 4 hardware alarms del temporizador de sistema para hacer parpadear 4 LEDs de manera independiente, programando cada pr\u00f3ximo \u201cdeadline\u201d en microsegundos dentro de cada ISR (interrupt service routine). Es un enfoque sin bloqueo: todo el parpadeo ocurre en las ISRs; el while(true) queda libre.</p>"},{"location":"timer/#objetivo","title":"Objetivo","text":"<p>Controlar 4 LEDs con periodos distintos usando ALARM0..ALARM3 del perif\u00e9rico timer. Trabajar en microsegundos (timebase de 1 MHz). Mantener precisi\u00f3n temporal reprogramando el siguiente disparo desde el deadline previo (evita drift). Plataforma y dependencias MCU: RP2350 (Raspberry Pi Pico 2) SDK: Raspberry Pi Pico SDK Headers: pico/stdlib.h, hardware/irq.h, hardware/structs/timer.h, hardware/gpio.h Mapa de pines y alarmas Recurso Definici\u00f3n  Uso en c\u00f3digo LED0    LED0_PIN = 12   Parpadeo con ALARM0 LED1    LED1_PIN = 13   Parpadeo con ALARM1 LED2    LED2_PIN = 14   Parpadeo con ALARM2 LED3    LED3_PIN = 15   Parpadeo con ALARM3 ALARM0  ALARM0_NUM = 0  IRQ ALARM0_IRQ \u2192 on_alarm0_irq() ALARM1  ALARM1_NUM = 1  IRQ ALARM1_IRQ \u2192 on_alarm1_irq() ALARM2  ALARM2_NUM = 2  IRQ ALARM2_IRQ \u2192 on_alarm2_irq() ALARM3  ALARM3_NUM = 3  IRQ ALARM3_IRQ \u2192 on_alarm3_irq() Nota: Asegura que los comentarios de pines coinciden con los #define usados.</p>"},{"location":"timer/#periodos-y-frecuencias","title":"Periodos y frecuencias","text":"<p>Los intervalos est\u00e1n en \u00b5s:</p> <p>INTERVALO0_US = 250000 \u2192 0.25 s \u2192 4 Hz INTERVALO1_US = 500000 \u2192 0.50 s \u2192 2 Hz INTERVALO2_US = 750000 \u2192 0.75 s \u2192 1.33 Hz INTERVALO3_US = 1000000 \u2192 1.00 s \u2192 1 Hz Cambia estas constantes para ajustar la velocidad de cada LED.</p>"},{"location":"timer/#flujo-de-ejecucion","title":"Flujo de ejecuci\u00f3n","text":"<p>Inicializaci\u00f3n de GPIOs: gpio_init(), gpio_set_dir(..., GPIO_OUT) y gpio_put(..., 0) por LED. Base de tiempo: timer_hw-&gt;source = 0u; (1 MHz \u2192 1 \u00b5s por tick). Captura \u201cahora\u201d: now_us = timer_hw-&gt;timerawl; (32 bits bajos). Deadlines iniciales: nextX_us = now_us + INTERVALOX_US (X=0..3). Programaci\u00f3n de alarmas: timer_hw-&gt;alarm[ALARMX_NUM] = nextX_us. ISRs registradas y IRQs habilitadas. Bucle principal: tight_loop_contents(); (sin trabajo, todo ocurre en ISRs). Rutinas de interrupci\u00f3n (ISRs) Cada ISR:</p> <p>Limpia su flag: hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMX_NUM); Conmuta el pin: sio_hw-&gt;gpio_togl = 1u &lt;&lt; LEDX_PIN; Reagenda desde el deadline: nextX_us += INTERVALOX_US; Reprograma su alarma: timer_hw-&gt;alarm[ALARMX_NUM] = nextX_us; Reagendar desde el deadline previo evita el drift que ocurrir\u00eda si se usara el \u201ctiempo actual\u201d.</p>"},{"location":"timer/#consideraciones-de-temporizacion","title":"Consideraciones de temporizaci\u00f3n","text":"<p>Rollover 32 bit: timerawl/nextX_us envuelven cada \u2248 71.58 min (2^32 \u00b5s). El esquema por deadlines lo maneja bien si todo se mantiene en 32 bits.</p> <p>SIO toggle: Requiere GPIO en funci\u00f3n SIO (por defecto tras gpio_init()). Es at\u00f3mico y r\u00e1pido.</p> <p>ISRs ligeras: Evita trabajo pesado dentro de interrupciones.</p>"},{"location":"timer/#errores-comunes-y-correcciones","title":"Errores comunes y correcciones","text":"<p>Programaci\u00f3n de alarmas 2 y 3 (\u00edndices equivocados):  ```c // Incorrecto (sobrescribe 0 y 1): timer_hw-&gt;alarm[ALARM0_NUM] = next0_us; timer_hw-&gt;alarm[ALARM1_NUM] = next1_us; timer_hw-&gt;alarm[ALARM0_NUM] = next2_us; // \u2190 Debe ser ALARM2_NUM timer_hw-&gt;alarm[ALARM1_NUM] = next3_us; // \u2190 Debe ser ALARM3_NUM // Correcto: timer_hw-&gt;alarm[ALARM0_NUM] = next0_us; timer_hw-&gt;alarm[ALARM1_NUM] = next1_us; timer_hw-&gt;alarm[ALARM2_NUM] = next2_us; timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;</p> <p>// Dos/4 LEDs con m\u00faltiples alarmas del timer de sistema (RP2350 / Pico 2) en \u00b5s. // Cada ALARMx controla un LED distinto. Ajusta INTERVALO*_US para la velocidad. <pre><code>include \"pico/stdlib.h\"\ninclude \"hardware/irq.h\"\ninclude \"hardware/structs/timer.h\"\ninclude \"hardware/gpio.h\"\n// Pines de LED (ajusta seg\u00fan tu placa)\n\ndefine LED0_PIN 12\ndefine LED1_PIN 13\ndefine LED2_PIN 14\ndefine LED3_PIN 15\n// \u00cdndices de alarmas\n\ndefine ALARM0_NUM 0\ndefine ALARM1_NUM 1\ndefine ALARM2_NUM 2\ndefine ALARM3_NUM 3\n// N\u00fameros de IRQ ya resueltos por el SDK para cada alarma\n\ndefine ALARM0_IRQ timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\ndefine ALARM1_IRQ timer_hardware_alarm_get_irq_num(timer_hw, ALARM1_NUM)\ndefine ALARM2_IRQ timer_hardware_alarm_get_irq_num(timer_hw, ALARM2_NUM)\ndefine ALARM3_IRQ timer_hardware_alarm_get_irq_num(timer_hw, ALARM3_NUM)\n// Pr\u00f3ximos \"deadlines\" (32 bits bajos en \u00b5s) y sus intervalos static volatile uint32_t next0_us, next1_us, next2_us, next3_us; static const uint32_t INTERVALO0_US = 250000u; // 0.25 s static const uint32_t INTERVALO1_US = 500000u; // 0.50 s static const uint32_t INTERVALO2_US = 750000u; // 0.75 s static const uint32_t INTERVALO3_US = 1000000u; // 1.00 s\n\n// ISR para ALARM0 static void on_alarm0_irq(void) { hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM); sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN; next0_us += INTERVALO0_US; timer_hw-&gt;alarm[ALARM0_NUM] = next0_us; }\n\n// ISR para ALARM1 static void on_alarm1_irq(void) { hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM1_NUM); sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN; next1_us += INTERVALO1_US; timer_hw-&gt;alarm[ALARM1_NUM] = next1_us; }\n\n// ISR para ALARM2 static void on_alarm2_irq(void) { hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM2_NUM); sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN; next2_us += INTERVALO2_US; timer_hw-&gt;alarm[ALARM2_NUM] = next2_us; }\n\n// ISR para ALARM3 static void on_alarm3_irq(void) { hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM3_NUM); sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED3_PIN; next3_us += INTERVALO3_US; timer_hw-&gt;alarm[ALARM3_NUM] = next3_us; }\n\nint main() { // Inicializaci\u00f3n de GPIOs gpio_init(LED0_PIN); gpio_set_dir(LED0_PIN, GPIO_OUT); gpio_put(LED0_PIN, 0); gpio_init(LED1_PIN); gpio_set_dir(LED1_PIN, GPIO_OUT); gpio_put(LED1_PIN, 0); gpio_init(LED2_PIN); gpio_set_dir(LED2_PIN, GPIO_OUT); gpio_put(LED2_PIN, 0); gpio_init(LED3_PIN); gpio_set_dir(LED3_PIN, GPIO_OUT); gpio_put(LED3_PIN, 0);\n\n\n// Timer de sistema en microsegundos (por defecto source = 0 \u2192 1 MHz)\ntimer_hw-&gt;source = 0u;\n\n// Toma \"ahora\" (32 bits bajos)\nuint32_t now_us = timer_hw-&gt;timerawl;\n\n// Primeros deadlines\nnext0_us = now_us + INTERVALO0_US;\nnext1_us = now_us + INTERVALO1_US;\nnext2_us = now_us + INTERVALO2_US;\nnext3_us = now_us + INTERVALO3_US;\n\n// Programa las 4 alarmas\ntimer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\ntimer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\ntimer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\ntimer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n\n// Limpia flags pendientes antes de habilitar\nhw_clear_bits(&amp;timer_hw-&gt;intr,\n    (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM) | (1u &lt;&lt; ALARM3_NUM));\n\n// Registra handlers exclusivos para cada alarma\nirq_set_exclusive_handler(ALARM0_IRQ, on_alarm0_irq);\nirq_set_exclusive_handler(ALARM1_IRQ, on_alarm1_irq);\nirq_set_exclusive_handler(ALARM2_IRQ, on_alarm2_irq);\nirq_set_exclusive_handler(ALARM3_IRQ, on_alarm3_irq);\n\n// Habilita fuentes de interrupci\u00f3n en el perif\u00e9rico TIMER\nhw_set_bits(&amp;timer_hw-&gt;inte,\n    (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM) | (1u &lt;&lt; ALARM3_NUM));\n\n// Habilita IRQs en el NVIC\nirq_set_enabled(ALARM0_IRQ, true);\nirq_set_enabled(ALARM1_IRQ, true);\nirq_set_enabled(ALARM2_IRQ, true);\nirq_set_enabled(ALARM3_IRQ, true);\n\n// Bucle principal: todo el parpadeo ocurre en las ISRs\nwhile (true) {\n    tight_loop_contents();\n    }   \n}\n</code></pre></p>"}]}